#include "catch.hpp"
#include "ecoevolity/operator.hpp"

#include <limits>
#include <memory>

#include "ecoevolity/probability.hpp"
#include "ecoevolity/parameter.hpp"
#include "ecoevolity/stats_util.hpp"
#include "ecoevolity/rng.hpp"

RandomNumberGenerator _TEST_OPERATOR_RNG = RandomNumberGenerator();


TEST_CASE("Testing TimeSizeScaler with 4 pairs",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            //OperatorInterface& o = op_schedule.draw_operator(rng);
            op->operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeScaler with 4 pairs with constrained sizes",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeScaler with 4 pairs with fixed sizes",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        std::cout << op->header_string();
        std::cout << op->to_string(op_schedule);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeScaler with 4 singletons",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeScaler with mix of pairs and singletons",
        "[TimeSizeScaler]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeSizeScaler with 4 pairs and shared event",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeScaler with mix of pairs and singletons and shared event",
        "[TimeSizeScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeSizeScaler with 4 pairs with constrained sizes and shared event",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}


TEST_CASE("Testing tree-specific TimeSizeScaler with 4 pairs",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeScaler with 4 pairs with constrained sizes",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeScaler with 4 pairs with fixed sizes",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeScaler with 4 singletons",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeScaler with mix of pairs and singletons",
        "[TimeSizeScaler]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeSizeScaler with 4 pairs and shared event",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeScaler with mix of pairs and singletons and shared event",
        "[TimeSizeScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeSizeScaler with 4 pairs with constrained sizes and shared event",
        "[TimeSizeScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizescaler-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizescaler-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}


TEST_CASE("Testing TimeSizeMixer with 4 pairs",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeMixer>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeMixer with 4 pairs with constrained sizes",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeMixer>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeMixer with 4 pairs with fixed sizes",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        std::cout << op->header_string();
        std::cout << op->to_string(op_schedule);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeMixer with 4 singletons",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeMixer>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeMixer with mix of pairs and singletons",
        "[TimeSizeMixer]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeMixer>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeSizeMixer with 4 pairs and shared event",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeMixer>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeMixer with mix of pairs and singletons and shared event",
        "[TimeSizeMixer]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeMixer>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeSizeMixer with 4 pairs with constrained sizes and shared event",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeMixer>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}


TEST_CASE("Testing tree-specific TimeSizeMixer with 4 pairs",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeMixer with 4 pairs with constrained sizes",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing time-specific TimeSizeMixer with 4 pairs with fixed sizes",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeMixer>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeMixer with 4 singletons",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeMixer with mix of pairs and singletons",
        "[TimeSizeMixer]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeSizeMixer with 4 pairs and shared event",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeMixer with mix of pairs and singletons and shared event",
        "[TimeSizeMixer]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeSizeMixer with 4 pairs with constrained sizes and shared event",
        "[TimeSizeMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizemixer-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizemixer-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        }
    }
}


TEST_CASE("Testing TimeSizeRateScaler with 4 pairs",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 pairs with constrained sizes",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 pairs with fixed sizes",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 singletons",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with mix of pairs and singletons",
        "[TimeSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 pairs and shared event",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with mix of pairs and singletons and shared event",
        "[TimeSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 pairs with constrained sizes and shared event",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 pairs and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test9-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test9-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 pairs with constrained sizes and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test10-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test10-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 pairs with fixed sizes and rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed sizes and rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test11-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test11-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        std::cout << op->header_string();
        std::cout << op->to_string(op_schedule);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 singletons and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 singletons and fixed rates with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test12-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test12-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with mix of pairs and singletons and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test13-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test13-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 pairs and shared event and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test14-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test14-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateScaler with mix of pairs and singletons and shared event and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test15-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test15-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeSizeRateScaler with 4 pairs with constrained sizes and shared event and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test16-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test16-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}


TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs with constrained sizes",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs with fixed sizes",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 singletons",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with mix of pairs and singletons",
        "[TimeSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 750000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs and shared event",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with mix of pairs and singletons and shared event",
        "[TimeSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs with constrained sizes and shared event",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test9-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test9-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs with constrained sizes and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test10-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test10-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs with fixed sizes and rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed sizes and rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test11-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test11-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 singletons and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 singletons and fixed rates with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test12-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test12-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with mix of pairs and singletons and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test13-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test13-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs and shared event and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test14-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test14-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with mix of pairs and singletons and shared event and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test15-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test15-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateScaler with 4 pairs with constrained sizes and shared event and fixed rates",
        "[TimeSizeRateScaler]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratescaler-test16-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratescaler-test16-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}


TEST_CASE("Testing TimeSizeRateMixer with 4 pairs",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 pairs with constrained sizes",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 pairs with fixed sizes",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 singletons",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with mix of pairs and singletons",
        "[TimeSizeRateMixer]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 pairs and shared event",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with mix of pairs and singletons and shared event",
        "[TimeSizeRateMixer]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 pairs with constrained sizes and shared event",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 pairs and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test9-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test9-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 pairs with constrained sizes and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test10-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test10-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 pairs with fixed sizes and rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed sizes and rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test11-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test11-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        std::cout << op->header_string();
        std::cout << op->to_string(op_schedule);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 singletons and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 singletons and fixed rates with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test12-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test12-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with mix of pairs and singletons and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing mix of pairs and singletons with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test13-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test13-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 pairs and shared event and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test14-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test14-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeSizeRateMixer with mix of pairs and singletons and shared event and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing mix of pairs and singletons with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test15-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test15-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeSizeRateMixer with 4 pairs with constrained sizes and shared event and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test16-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test16-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs with constrained sizes",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs with fixed sizes",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 singletons",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with mix of pairs and singletons",
        "[TimeSizeRateMixer]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs and shared event",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with mix of pairs and singletons and shared event",
        "[TimeSizeRateMixer]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs with constrained sizes and shared event",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test9-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test9-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs with constrained sizes and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test10-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test10-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs with fixed sizes and rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed sizes and rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test11-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test11-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                        REQUIRE(size_leaf1 == 0.01);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(0.01));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(0.0));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 singletons and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 singletons and fixed rates with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test12-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test12-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 800000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_leaf1 = tree->get_child_population_size(0);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(tree->get_leaf_node_count() == 1);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with mix of pairs and singletons and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing mix of pairs and singletons with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test13-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test13-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs and shared event and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test14-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test14-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_leaf2_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 != size_leaf2);
                        REQUIRE(size_leaf1 != size_root);
                        REQUIRE(size_leaf2 != size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    size_leaf2_summaries.at(tree_idx).add_sample(size_leaf2);
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_leaf2_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf2_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf2_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with mix of pairs and singletons and shared event and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing mix of pairs and singletons with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test15-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test15-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<LeafPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_root_summary_pair1;
        SampleSummarizer<double> size_root_summary_pair2;
        SampleSummarizer<double> size_root_summary_pair3;
        SampleSummarizer<double> size_root_summary_single1;
        SampleSummarizer<double> size_root_summary_single2;
        SampleSummarizer<double> size_leaf_summary_pair1;
        SampleSummarizer<double> size_leaf_summary_single1;
        SampleSummarizer<double> size_leaf_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_root_pair1 = comparisons.get_tree(0)->get_root_population_size();
                double size_leaf1_pair1 = comparisons.get_tree(0)->get_child_population_size(0);
                double size_leaf2_pair1 = comparisons.get_tree(0)->get_child_population_size(1);

                double  size_root_pair2 = comparisons.get_tree(1)->get_root_population_size();
                double size_leaf1_pair2 = comparisons.get_tree(1)->get_child_population_size(0);
                double size_leaf2_pair2 = comparisons.get_tree(1)->get_child_population_size(1);

                double  size_root_pair3 = comparisons.get_tree(2)->get_root_population_size();
                double size_leaf1_pair3 = comparisons.get_tree(2)->get_child_population_size(0);
                double size_leaf2_pair3 = comparisons.get_tree(2)->get_child_population_size(1);

                double size_root_single1 = comparisons.get_tree(3)->get_root_population_size();
                double size_leaf_single1 = comparisons.get_tree(3)->get_child_population_size(0);

                double size_root_single2 = comparisons.get_tree(4)->get_root_population_size();
                double size_leaf_single2 = comparisons.get_tree(4)->get_child_population_size(0);

                if (i > (niterations - (sample_freq * 5))) {
                    REQUIRE(size_leaf1_pair1 != size_leaf2_pair1);
                    REQUIRE(size_leaf1_pair1 != size_root_pair1);
                    REQUIRE(size_leaf2_pair1 != size_root_pair1);

                    REQUIRE(size_leaf1_pair2 == size_leaf2_pair2);
                    REQUIRE(size_leaf1_pair2 == size_root_pair2);

                    REQUIRE(size_leaf1_pair3 == 0.01);
                    REQUIRE(size_leaf1_pair3 == size_leaf2_pair3);
                    REQUIRE(size_leaf1_pair3 == size_root_pair3);

                    REQUIRE(comparisons.get_tree(3)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single1 != size_root_single1);

                    REQUIRE(comparisons.get_tree(4)->get_leaf_node_count() == 1);
                    REQUIRE(size_leaf_single2 != size_root_single2);
                }

                size_leaf_summary_pair1.add_sample(size_leaf1_pair1);
                size_leaf_summary_pair1.add_sample(size_leaf2_pair1);

                size_leaf_summary_single1.add_sample(size_leaf_single1);
                size_leaf_summary_single2.add_sample(size_leaf_single2);

                size_root_summary_pair1.add_sample(size_root_pair1);
                size_root_summary_pair2.add_sample(size_root_pair2);
                size_root_summary_pair3.add_sample(size_root_pair3);
                size_root_summary_single1.add_sample(size_root_single1);
                size_root_summary_single2.add_sample(size_root_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_leaf_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_root_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_root_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_root_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_leaf_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_leaf_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_leaf_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_root_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeSizeRateMixer with 4 pairs with constrained sizes and shared event and fixed rates",
        "[TimeSizeRateMixer]") {

    SECTION("Testing 4 pairs with constrained sizes and shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-comptimesizeratemixer-test16-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-comptimesizeratemixer-test16-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RootPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_leaf1_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_leaf1;
        double size_leaf2;
        double size_root;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_leaf1 = tree->get_child_population_size(0);
                    size_leaf2 = tree->get_child_population_size(1);
                    size_root = tree->get_root_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    if (i > (niterations - (sample_freq * 5))) {
                        REQUIRE(size_leaf1 == size_leaf2);
                        REQUIRE(size_leaf1 == size_root);
                    }
                    size_leaf1_summaries.at(tree_idx).add_sample(size_leaf1);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_leaf1_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_leaf1_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_leaf1_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing EventTimeScaler", "[EventTimeScaler]") {

    SECTION("Testing gamma(10.0, 0.1) prior and no optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << shape << "\n";
        out << "        scale: " << scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<EventTimeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        os.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double h;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            h = comparisons.get_height(0);
            mn = std::min(mn, h);
            mx = std::max(mx, h);
            ++n;
            d = h - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        
        REQUIRE(mean == Approx(shape * scale).epsilon(0.001));
        REQUIRE(variance == Approx(shape * scale * scale).epsilon(0.001));
        REQUIRE(mn >= 0.0);
    }

    SECTION("Testing gamma(10.0, 0.1) prior and with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << shape << "\n";
        out << "        scale: " << scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<EventTimeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double h;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            h = comparisons.get_height(0);
            mn = std::min(mn, h);
            mx = std::max(mx, h);
            ++n;
            d = h - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        
        REQUIRE(mean == Approx(shape * scale).epsilon(0.001));
        REQUIRE(variance == Approx(shape * scale * scale).epsilon(0.001));
        REQUIRE(mn >= 0.0);
    }
}

TEST_CASE("Testing EventTimeMover", "[EventTimeMover]") {

    SECTION("Testing gamma(10.0, 0.1) prior and no optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << shape << "\n";
        out << "        scale: " << scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<EventTimeMover>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        os.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double h;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            h = comparisons.get_height(0);
            mn = std::min(mn, h);
            mx = std::max(mx, h);
            ++n;
            d = h - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        
        REQUIRE(mean == Approx(shape * scale).epsilon(0.001));
        REQUIRE(variance == Approx(shape * scale * scale).epsilon(0.001));
        REQUIRE(mn >= 0.0);
    }

    SECTION("Testing gamma(10.0, 0.1) prior and with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << shape << "\n";
        out << "        scale: " << scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<EventTimeMover>(1.0, 0.2);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double h;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            h = comparisons.get_height(0);
            mn = std::min(mn, h);
            mx = std::max(mx, h);
            ++n;
            d = h - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        
        REQUIRE(mean == Approx(shape * scale).epsilon(0.001));
        REQUIRE(variance == Approx(shape * scale * scale).epsilon(0.001));
        REQUIRE(mn >= 0.0);
    }
}


TEST_CASE("Testing RootPopulationSizeScaler", "[RootPopulationSizeScaler]") {

    SECTION("Testing gamma(10.0, 0.1) prior and no optimizing") {

        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: false\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12933);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RootPopulationSizeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        // os.turn_on_auto_optimize();
        // os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<GammaDistribution>(shape, scale);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_root_population_size();
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.001));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        //REQUIRE(mn == Approx(prior->get_min()).epsilon(0.001));
        //REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
        
    }

    SECTION("Testing gamma(10.0, 0.1) prior with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: false\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12933);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RootPopulationSizeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        //os.turn_off_auto_optimize();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<GammaDistribution>(shape, scale);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_root_population_size();
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.001));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        //REQUIRE(mn == Approx(prior->get_min()).epsilon(0.001));
        //REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
        
    }
}

TEST_CASE("Testing LeafPopulationSizeScaler", "[LeafPopulationSizeScaler]") {

    SECTION("Testing gamma(10.0, 0.1) prior and no optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: false\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12933);
        std::shared_ptr<OperatorInterface> op = std::make_shared<LeafPopulationSizeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        // os.turn_on_auto_optimize();
        // os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<GammaDistribution>(shape, scale);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_child_population_size(0);
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.001));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        //REQUIRE(mn == Approx(prior->get_min()).epsilon(0.001));
        //REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
    }

    SECTION("Testing gamma(10.0, 0.1) prior with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: false\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12933);
        std::shared_ptr<OperatorInterface> op = std::make_shared<LeafPopulationSizeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        // os.turn_off_auto_optimize();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<GammaDistribution>(shape, scale);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_child_population_size(0);
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.001));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        //REQUIRE(mn == Approx(prior->get_min()).epsilon(0.001));
        //REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
    }
}

TEST_CASE("Testing MutationRateScaler", "[MutationRateScaler]") {

    SECTION("Testing gamma(10.0, 0.1) prior and no optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<MutationRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        // os.turn_on_auto_optimize();
        // os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<GammaDistribution>(shape, scale);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 100000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_mutation_rate();
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.001));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        //REQUIRE(mn == Approx(prior->get_min()).epsilon(0.001));
        //REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
        
    }

    SECTION("Testing gamma(10.0, 0.1) prior and no optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(928374);
        std::shared_ptr<OperatorInterface> op = std::make_shared<MutationRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        // os.turn_off_auto_optimize();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<GammaDistribution>(shape, scale);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 100000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_mutation_rate();
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.001));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        //REQUIRE(mn == Approx(prior->get_min()).epsilon(0.001));
        //REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
        
    }
}

TEST_CASE("Testing FreqMover", "[FreqMover]") {

    SECTION("testing beta(1.0, 1.0) prior and no optimizing") {
        double alpha = 1.0;
        double beta = 1.0;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                beta_distribution:\n";
        out << "                    alpha: " << alpha << "\n";
        out << "                    beta: " << beta << "\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<FreqMover>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        // os.turn_on_auto_optimize();
        // os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<BetaDistribution>(alpha, beta);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 100000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_freq_1();
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.005));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        REQUIRE(mn == Approx(prior->get_min()).epsilon(0.001));
        REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
    }

    SECTION("testing beta(1.0, 1.0) prior with optimizing") {
        double alpha = 1.0;
        double beta = 1.0;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                beta_distribution:\n";
        out << "                    alpha: " << alpha << "\n";
        out << "                    beta: " << beta << "\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(3648);
        std::shared_ptr<OperatorInterface> op = std::make_shared<FreqMover>(1.0, 0.1);
        OperatorSchedule os = OperatorSchedule();
        // os.turn_off_auto_optimize();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<BetaDistribution>(alpha, beta);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 100000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_freq_1();
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.005));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        REQUIRE(mn == Approx(prior->get_min()).epsilon(0.001));
        REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
    }

    SECTION("testing beta(5.0, 1.0) prior and no optimizing") {
        double alpha = 5.0;
        double beta = 1.0;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                beta_distribution:\n";
        out << "                    alpha: " << alpha << "\n";
        out << "                    beta: " << beta << "\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(3648);
        std::shared_ptr<OperatorInterface> op = std::make_shared<FreqMover>(1.0, 0.1);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        // os.turn_on_auto_optimize();
        // os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<BetaDistribution>(alpha, beta);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 100000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_freq_1();
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.005));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
    }

    SECTION("testing beta(5.0, 1.0) prior with optimizing") {
        double alpha = 5.0;
        double beta = 1.0;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                beta_distribution:\n";
        out << "                    alpha: " << alpha << "\n";
        out << "                    beta: " << beta << "\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(3648);
        std::shared_ptr<OperatorInterface> op = std::make_shared<FreqMover>(1.0, 0.1);
        OperatorSchedule os = OperatorSchedule();
        // os.turn_off_auto_optimize();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<BetaDistribution>(alpha, beta);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 100000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_freq_1();
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.005));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        REQUIRE(mx == Approx(prior->get_max()).epsilon(0.001));
    }

    SECTION("testing beta(1.0, 5.0) prior with optimizing") {
        double alpha = 1.0;
        double beta = 5.0;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                beta_distribution:\n";
        out << "                    alpha: " << alpha << "\n";
        out << "                    beta: " << beta << "\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(3648);
        std::shared_ptr<OperatorInterface> op = std::make_shared<FreqMover>(1.0, 0.1);
        OperatorSchedule os = OperatorSchedule();
        // os.turn_off_auto_optimize();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        std::shared_ptr<ContinuousProbabilityDistribution> prior = std::make_shared<BetaDistribution>(alpha, beta);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 100000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            double x = comparisons.get_tree(0)->get_freq_1();
            mn = std::min(mn, x);
            mx = std::max(mx, x);
            ++n;
            d = x - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        std::cout << "prior mean: " << mean << "\n";
        std::cout << "prior variance: " << variance << "\n";
        std::cout << "expected prior mean: " << prior->get_mean() << "\n";
        std::cout << "expected prior variance: " << prior->get_variance() << "\n";
        
        REQUIRE(mean == Approx(prior->get_mean()).epsilon(0.005));
        REQUIRE(variance == Approx(prior->get_variance()).epsilon(0.001));
        REQUIRE(mn >= prior->get_min());
        REQUIRE(mx < prior->get_max());
        REQUIRE(mn == Approx(prior->get_min()).epsilon(0.001));
    }
}

TEST_CASE("Testing DirichletProcessGibbsSampler with 3 pairs and concentration 1.4142",
        "[DirichletProcessGibbsSampler]") {

    SECTION("Testing 3 pairs, conc 1.4142, with optimizing") {
        double concentration = 1.4142;
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-dpgibbssamper-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-dpgibbssampler-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "event_model_prior:\n";
        os << "    dirichlet_process:\n";
        os << "        parameters:\n";
        os << "            concentration:\n";
        os << "                value: " << concentration << "\n";
        os << "                estimate: false\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: false\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.002\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<DirichletProcessGibbsSampler>(1.0, 2);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);

        std::map<std::string, int> model_counts;
        std::map<int, int> nevent_counts;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        std::vector<unsigned int> height_indices(ntrees, 0);
        unsigned int nevents;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                nevents = comparisons.get_number_of_events();
                height_indices = comparisons.get_standardized_height_indices();
                std::ostringstream stream;
                for (auto h_idx : height_indices) {
                    stream << h_idx;
                }
                std::string model_str = stream.str();
                if (model_counts.count(model_str) < 1) {
                    model_counts[model_str] = 1;
                }
                else {
                    ++model_counts[model_str];
                }
                if (nevent_counts.count(nevents) < 1) {
                    nevent_counts[nevents] = 1;
                }
                else {
                    ++nevent_counts[nevents];
                }
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        }

        REQUIRE(model_counts.at("000") == nevent_counts.at(1));
        REQUIRE(model_counts.at("012") == nevent_counts.at(3));
        REQUIRE((model_counts.at("001") + model_counts.at("010") + model_counts.at("011")) == nevent_counts.at(2));
        unsigned int tally = 0;
        for (auto const & kv: model_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);
        tally = 0;
        for (auto const & kv: nevent_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);

        for (auto const & kv: model_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: nevent_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: model_counts) {
            REQUIRE((kv.second / (double)nsamples) == Approx(std::exp(
                    get_dpp_log_prior_probability(kv.first, concentration))).epsilon(0.002));
        }
    }
}

TEST_CASE("Testing DirichletProcessGibbsSampler with 6 pairs and concentration 1.7",
        "[DirichletProcessGibbsSampler]") {

    SECTION("Testing 6 pairs, conc 1.7, with optimizing") {
        double concentration = 1.7;
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-dpgibbssamper-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-dpgibbssampler-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "event_model_prior:\n";
        os << "    dirichlet_process:\n";
        os << "        parameters:\n";
        os << "            concentration:\n";
        os << "                value: " << concentration << "\n";
        os << "                estimate: false\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: false\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.002\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname5.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<DirichletProcessGibbsSampler>(1.0, 3);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 6);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);

        std::map<std::string, int> model_counts;
        std::map<int, int> nevent_counts;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        std::vector<unsigned int> height_indices(ntrees, 0);
        unsigned int nevents;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                nevents = comparisons.get_number_of_events();
                height_indices = comparisons.get_standardized_height_indices();
                std::ostringstream stream;
                for (auto h_idx : height_indices) {
                    stream << h_idx;
                }
                std::string model_str = stream.str();
                if (model_counts.count(model_str) < 1) {
                    model_counts[model_str] = 1;
                }
                else {
                    ++model_counts[model_str];
                }
                if (nevent_counts.count(nevents) < 1) {
                    nevent_counts[nevents] = 1;
                }
                else {
                    ++nevent_counts[nevents];
                }
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        }

        REQUIRE(model_counts.at("000000") == nevent_counts.at(1));
        REQUIRE(model_counts.at("012345") == nevent_counts.at(6));
        unsigned int tally = 0;
        for (auto const & kv: model_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);
        tally = 0;
        for (auto const & kv: nevent_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);

        for (auto const & kv: model_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: nevent_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: model_counts) {
            REQUIRE((kv.second / (double)nsamples) == Approx(std::exp(
                    get_dpp_log_prior_probability(kv.first, concentration))).epsilon(0.005));
        }
    }
}

TEST_CASE("Testing ReversibleJumpSampler with 3 pairs and split weight 1.0",
        "[ReversibleJumpSampler]") {

    SECTION("Testing 3 pairs and split weight 1.0,") {
        double split_weight = 1.0;
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-rjsampler-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-rjsampler-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "event_model_prior:\n";
        os << "    uniform:\n";
        os << "        parameters:\n";
        os << "            split_weight:\n";
        os << "                value: " << split_weight << "\n";
        os << "                estimate: false\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: false\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.002\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<ReversibleJumpSampler>(1.0);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        SampleSummarizer<double> split_weight_summary;

        std::map<std::string, int> model_counts;
        std::map<int, int> nevent_counts;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 1000000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        std::vector<unsigned int> height_indices(ntrees, 0);
        unsigned int nevents;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                split_weight_summary.add_sample(comparisons.get_concentration());
                nevents = comparisons.get_number_of_events();
                height_indices = comparisons.get_standardized_height_indices();
                std::ostringstream stream;
                for (auto h_idx : height_indices) {
                    stream << h_idx;
                }
                std::string model_str = stream.str();
                if (model_counts.count(model_str) < 1) {
                    model_counts[model_str] = 1;
                }
                else {
                    ++model_counts[model_str];
                }
                if (nevent_counts.count(nevents) < 1) {
                    nevent_counts[nevents] = 1;
                }
                else {
                    ++nevent_counts[nevents];
                }
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(model_counts.at("000") == nevent_counts.at(1));
        REQUIRE(model_counts.at("012") == nevent_counts.at(3));
        REQUIRE((model_counts.at("001") + model_counts.at("010") + model_counts.at("011")) == nevent_counts.at(2));
        unsigned int tally = 0;
        for (auto const & kv: model_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);
        tally = 0;
        for (auto const & kv: nevent_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);

        for (auto const & kv: model_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: nevent_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: model_counts) {
            REQUIRE((kv.second / (double)nsamples) == Approx(1.0/model_counts.size()).epsilon(0.002));
        }
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        }
        REQUIRE(split_weight_summary.sample_size() == nsamples);
        REQUIRE(split_weight_summary.mean() == Approx(1.0));
        REQUIRE(split_weight_summary.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing ReversibleJumpSampler with 3 pairs and split weight 2.0",
        "[ReversibleJumpSampler]") {

    SECTION("Testing 3 pairs and split weight 2.0,") {
        double split_weight = 2.0;
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-rjsampler-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-rjsampler-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "event_model_prior:\n";
        os << "    uniform:\n";
        os << "        parameters:\n";
        os << "            split_weight:\n";
        os << "                value: " << split_weight << "\n";
        os << "                estimate: false\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: false\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.002\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<ReversibleJumpSampler>(1.0);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        SampleSummarizer<double> split_weight_summary;

        std::map<std::string, int> model_counts;
        std::map<int, int> nevent_counts;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 1000000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        std::vector<unsigned int> height_indices(ntrees, 0);
        unsigned int nevents;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                split_weight_summary.add_sample(comparisons.get_concentration());
                nevents = comparisons.get_number_of_events();
                height_indices = comparisons.get_standardized_height_indices();
                std::ostringstream stream;
                for (auto h_idx : height_indices) {
                    stream << h_idx;
                }
                std::string model_str = stream.str();
                if (model_counts.count(model_str) < 1) {
                    model_counts[model_str] = 1;
                }
                else {
                    ++model_counts[model_str];
                }
                if (nevent_counts.count(nevents) < 1) {
                    nevent_counts[nevents] = 1;
                }
                else {
                    ++nevent_counts[nevents];
                }
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(model_counts.at("000") == nevent_counts.at(1));
        REQUIRE(model_counts.at("012") == nevent_counts.at(3));
        REQUIRE((model_counts.at("001") + model_counts.at("010") + model_counts.at("011")) == nevent_counts.at(2));
        unsigned int tally = 0;
        for (auto const & kv: model_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);
        tally = 0;
        for (auto const & kv: nevent_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);

        for (auto const & kv: model_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: nevent_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        REQUIRE(split_weight_summary.sample_size() == nsamples);
        REQUIRE(split_weight_summary.mean() == Approx(2.0));
        REQUIRE(split_weight_summary.variance() == Approx(0.0));
        for (std::string m: {"001", "010", "011"}) {
            REQUIRE((model_counts.at(m) / (double)nsamples) == Approx(2.0/11.0).epsilon(0.001));
        }
        REQUIRE((model_counts.at("000") / (double)nsamples) == Approx(1.0/11.0).epsilon(0.001));
        REQUIRE((model_counts.at("012") / (double)nsamples) == Approx(4.0/11.0).epsilon(0.001));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing ReversibleJumpSampler with 3 pairs and split weight 0.5",
        "[ReversibleJumpSampler]") {

    SECTION("Testing 3 pairs and split weight 0.5,") {
        double split_weight = 0.5;
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-rjsampler-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-rjsampler-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "event_model_prior:\n";
        os << "    uniform:\n";
        os << "        parameters:\n";
        os << "            split_weight:\n";
        os << "                value: " << split_weight << "\n";
        os << "                estimate: false\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: false\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.002\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<ReversibleJumpSampler>(1.0);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        SampleSummarizer<double> split_weight_summary;

        std::map<std::string, int> model_counts;
        std::map<int, int> nevent_counts;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 1000000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        std::vector<unsigned int> height_indices(ntrees, 0);
        unsigned int nevents;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                split_weight_summary.add_sample(comparisons.get_concentration());
                nevents = comparisons.get_number_of_events();
                height_indices = comparisons.get_standardized_height_indices();
                std::ostringstream stream;
                for (auto h_idx : height_indices) {
                    stream << h_idx;
                }
                std::string model_str = stream.str();
                if (model_counts.count(model_str) < 1) {
                    model_counts[model_str] = 1;
                }
                else {
                    ++model_counts[model_str];
                }
                if (nevent_counts.count(nevents) < 1) {
                    nevent_counts[nevents] = 1;
                }
                else {
                    ++nevent_counts[nevents];
                }
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(model_counts.at("000") == nevent_counts.at(1));
        REQUIRE(model_counts.at("012") == nevent_counts.at(3));
        REQUIRE((model_counts.at("001") + model_counts.at("010") + model_counts.at("011")) == nevent_counts.at(2));
        unsigned int tally = 0;
        for (auto const & kv: model_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);
        tally = 0;
        for (auto const & kv: nevent_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);

        for (auto const & kv: model_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: nevent_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        REQUIRE(split_weight_summary.sample_size() == nsamples);
        REQUIRE(split_weight_summary.mean() == Approx(0.5));
        REQUIRE(split_weight_summary.variance() == Approx(0.0));
        for (std::string m: {"001", "010", "011"}) {
            REQUIRE((model_counts.at(m) / (double)nsamples) == Approx(2.0/11.0).epsilon(0.002));
        }
        REQUIRE((model_counts.at("012") / (double)nsamples) == Approx(1.0/11.0).epsilon(0.001));
        REQUIRE((model_counts.at("000") / (double)nsamples) == Approx(4.0/11.0).epsilon(0.001));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing ReversibleJumpSampler with 4 pairs and split weight 3.0",
        "[ReversibleJumpSampler]") {

    SECTION("Testing 4 pairs and split weight 3.0,") {
        double split_weight = 3.0;
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-rjsampler-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-rjsampler-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "event_model_prior:\n";
        os << "    uniform:\n";
        os << "        parameters:\n";
        os << "            split_weight:\n";
        os << "                value: " << split_weight << "\n";
        os << "                estimate: false\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: false\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.002\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<ReversibleJumpSampler>(1.0);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        SampleSummarizer<double> split_weight_summary;

        std::map<std::string, int> model_counts;
        std::map<int, int> nevent_counts;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 1000000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        std::vector<unsigned int> height_indices(ntrees, 0);
        unsigned int nevents;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                split_weight_summary.add_sample(comparisons.get_concentration());
                nevents = comparisons.get_number_of_events();
                height_indices = comparisons.get_standardized_height_indices();
                std::ostringstream stream;
                for (auto h_idx : height_indices) {
                    stream << h_idx;
                }
                std::string model_str = stream.str();
                if (model_counts.count(model_str) < 1) {
                    model_counts[model_str] = 1;
                }
                else {
                    ++model_counts[model_str];
                }
                if (nevent_counts.count(nevents) < 1) {
                    nevent_counts[nevents] = 1;
                }
                else {
                    ++nevent_counts[nevents];
                }
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(model_counts.at("0000") == nevent_counts.at(1));
        REQUIRE(model_counts.at("0123") == nevent_counts.at(4));

        unsigned int tally = 0;
        for (auto const & kv: model_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);
        tally = 0;
        for (auto const & kv: nevent_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);

        for (auto const & kv: model_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: nevent_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        REQUIRE(split_weight_summary.sample_size() == nsamples);
        REQUIRE(split_weight_summary.mean() == Approx(3.0));
        REQUIRE(split_weight_summary.variance() == Approx(0.0));

        // Below are the expected results. 'k' is the number of categories,
        // 'S(n,k)' is the number of possible partitions of n elements into k
        // categories (Stirling number of second kind), 'w' is the relative split
        // weight for any one of those possible partitions, 'total_w' is the
        // overall weight of the k class (w * S(n,k)), and 'prob' is the
        // probability of any one possible partition in the k class.
        //
        // k    S(n,k)  w       total_w     prob
        // -------------------------------------
        // 1    1       1       1           1/103
        // 2    7       3       21          3/103
        // 3    6       9       54          9/103
        // 4    1       27      27          27/103
        //                      103

        REQUIRE((model_counts.at("0123") / (double)nsamples) == Approx(27.0/103.0).epsilon(0.001));
        REQUIRE((model_counts.at("0122") / (double)nsamples) == Approx(9.0/103.0).epsilon(0.001));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing ReversibleJumpSampler with 4 pairs and split weight 1/3.0",
        "[ReversibleJumpSampler]") {

    SECTION("Testing 4 pairs and split weight 1/3.0,") {
        double split_weight = 1.0/3.0;
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-rjsampler-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-rjsampler-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "event_model_prior:\n";
        os << "    uniform:\n";
        os << "        parameters:\n";
        os << "            split_weight:\n";
        os << "                value: " << split_weight << "\n";
        os << "                estimate: false\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: false\n";
        os << "    equal_population_sizes: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.002\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<ReversibleJumpSampler>(1.0);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);
        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        SampleSummarizer<double> split_weight_summary;

        std::map<std::string, int> model_counts;
        std::map<int, int> nevent_counts;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 1000000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        std::vector<unsigned int> height_indices(ntrees, 0);
        unsigned int nevents;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                split_weight_summary.add_sample(comparisons.get_concentration());
                nevents = comparisons.get_number_of_events();
                height_indices = comparisons.get_standardized_height_indices();
                std::ostringstream stream;
                for (auto h_idx : height_indices) {
                    stream << h_idx;
                }
                std::string model_str = stream.str();
                if (model_counts.count(model_str) < 1) {
                    model_counts[model_str] = 1;
                }
                else {
                    ++model_counts[model_str];
                }
                if (nevent_counts.count(nevents) < 1) {
                    nevent_counts[nevents] = 1;
                }
                else {
                    ++nevent_counts[nevents];
                }
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(model_counts.at("0000") == nevent_counts.at(1));
        REQUIRE(model_counts.at("0123") == nevent_counts.at(4));

        unsigned int tally = 0;
        for (auto const & kv: model_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);
        tally = 0;
        for (auto const & kv: nevent_counts) {
            tally += kv.second;
        }
        REQUIRE(tally == nsamples);

        for (auto const & kv: model_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        for (auto const & kv: nevent_counts) {
            std::cout << kv.first << ": " << kv.second / (double)nsamples << "\n";
        }
        REQUIRE(split_weight_summary.sample_size() == nsamples);
        REQUIRE(split_weight_summary.mean() == Approx(1.0/3.0));
        REQUIRE(split_weight_summary.variance() == Approx(0.0));

        // Below are the expected results. 'k' is the number of categories,
        // 'S(n,k)' is the number of possible partitions of n elements into k
        // categories (Stirling number of second kind), 'w' is the relative split
        // weight for any one of those possible partitions, 'total_w' is the
        // overall weight of the k class (w * S(n,k)), and 'prob' is the
        // probability of any one possible partition in the k class.
        //
        // k    S(n,k)  w       total_w     prob
        // -------------------------------------
        // 1    1       27      27          27/109
        // 2    7       9       63          9/109
        // 3    6       3       18          3/109
        // 4    1       1       1           1/109
        //                      109

        REQUIRE((model_counts.at("0000") / (double)nsamples) == Approx(27.0/109.0).epsilon(0.001));
        REQUIRE((model_counts.at("0001") / (double)nsamples) == Approx(9.0/109.0).epsilon(0.001));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing EventTimeScaler for dirichlet trees", "[EventTimeScaler]") {

    SECTION("Testing gamma(10.0, 0.1) prior and no optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << shape << "\n";
        out << "        scale: " << scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<EventTimeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double h;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            h = comparisons.get_height(0);
            mn = std::min(mn, h);
            mx = std::max(mx, h);
            ++n;
            d = h - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        
        REQUIRE(mean == Approx(shape * scale).epsilon(0.001));
        REQUIRE(variance == Approx(shape * scale * scale).epsilon(0.001));
        REQUIRE(mn >= 0.0);
    }

    SECTION("Testing gamma(10.0, 0.1) prior and with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << shape << "\n";
        out << "        scale: " << scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<EventTimeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double h;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            h = comparisons.get_height(0);
            mn = std::min(mn, h);
            mx = std::max(mx, h);
            ++n;
            d = h - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        
        REQUIRE(mean == Approx(shape * scale).epsilon(0.001));
        REQUIRE(variance == Approx(shape * scale * scale).epsilon(0.001));
        REQUIRE(mn >= 0.0);
    }
}

TEST_CASE("Testing MeanPopulationSizeScaler for dirichlet trees", "[MeanPopulationSizeScaler]") {

    SECTION("Testing gamma(10.0, 0.1) prior and no optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<MeanPopulationSizeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double s;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            s = comparisons.get_tree(0)->get_mean_population_size();
            mn = std::min(mn, s);
            mx = std::max(mx, s);
            ++n;
            d = s - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        
        REQUIRE(mean == Approx(shape * scale).epsilon(0.001));
        REQUIRE(variance == Approx(shape * scale * scale).epsilon(0.001));
        REQUIRE(mn >= 0.0);
    }

    SECTION("Testing gamma(10.0, 0.1) prior with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<MeanPopulationSizeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(10000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        comparisons.set_operator_schedule(os);
        unsigned int n = 0;
        double mean = 0.0;
        double sum_devs = 0.0;
        double s;
        double d;
        double d_n;
        double mn = std::numeric_limits<double>::max();
        double mx = -std::numeric_limits<double>::max();
        for (unsigned int i = 0; i < 1000000; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.perform_collection_move(rng, &comparisons, 1);
            s = comparisons.get_tree(0)->get_mean_population_size();
            mn = std::min(mn, s);
            mx = std::max(mx, s);
            ++n;
            d = s - mean;
            d_n = d / n;
            mean += d_n;
            sum_devs += d * d_n * (n - 1);
        }
        double variance = sum_devs / (n - 1);
        std::cout << op->header_string();
        std::cout << op->to_string(os);
        
        REQUIRE(mean == Approx(shape * scale).epsilon(0.001));
        REQUIRE(variance == Approx(shape * scale * scale).epsilon(0.001));
        REQUIRE(mn >= 0.0);
    }
}

TEST_CASE("Testing RelativePopulationSizeMixer for dirichlet(1, 1, 1)", "[RelativePopulationSizeMixer]") {

    SECTION("Testing dir(1, 1, 1) prior and no optimizing") {
        std::vector<double> alphas = {1.0, 1.0, 1.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RelativePopulationSizeMixer>(1.0, 10.0);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        std::vector<double> expected_means = dir_prior.get_mean();
        for (unsigned int i = 0; i < expected_means.size(); ++i) {
            expected_means.at(i) *= (double)nnodes;
        }
        std::vector<double> expected_variances = dir_prior.get_variance();
        for (unsigned int i = 0; i < expected_variances.size(); ++i) {
            expected_variances.at(i) *= ((double)nnodes * (double)nnodes);
        }

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_multipliers();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(expected_means.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.mean() == Approx(expected_means.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.mean() == Approx(expected_means.at(1)).epsilon(0.001));

        REQUIRE(multiplier_root_summary.variance() == Approx(expected_variances.at(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(expected_variances.at(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(expected_variances.at(1)).epsilon(0.005));
    }

    SECTION("Testing dir(1, 1, 1) prior with optimizing") {
        std::vector<double> alphas = {1.0, 1.0, 1.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RelativePopulationSizeMixer>(1.0, 1.0);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        std::vector<double> expected_means = dir_prior.get_mean();
        for (unsigned int i = 0; i < expected_means.size(); ++i) {
            expected_means.at(i) *= (double)nnodes;
        }
        std::vector<double> expected_variances = dir_prior.get_variance();
        for (unsigned int i = 0; i < expected_variances.size(); ++i) {
            expected_variances.at(i) *= ((double)nnodes * (double)nnodes);
        }

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_multipliers();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(expected_means.at(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(expected_means.at(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(expected_means.at(1)).epsilon(0.005));

        REQUIRE(multiplier_root_summary.variance() == Approx(expected_variances.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.variance() == Approx(expected_variances.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.variance() == Approx(expected_variances.at(1)).epsilon(0.001));
    }
}


TEST_CASE("Testing RelativePopulationSizeMixer for dirichlet(3, 3, 3)", "[RelativePopulationSizeMixer]") {

    SECTION("Testing dir(3, 3, 3) prior and no optimizing") {
        std::vector<double> alphas = {3.0, 3.0, 3.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RelativePopulationSizeMixer>(1.0, 1.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        std::vector<double> expected_means = dir_prior.get_mean();
        for (unsigned int i = 0; i < expected_means.size(); ++i) {
            expected_means.at(i) *= (double)nnodes;
        }
        std::vector<double> expected_variances = dir_prior.get_variance();
        for (unsigned int i = 0; i < expected_variances.size(); ++i) {
            expected_variances.at(i) *= ((double)nnodes * (double)nnodes);
        }

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_multipliers();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(expected_means.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.mean() == Approx(expected_means.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.mean() == Approx(expected_means.at(1)).epsilon(0.001));

        REQUIRE(multiplier_root_summary.variance() == Approx(expected_variances.at(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(expected_variances.at(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(expected_variances.at(1)).epsilon(0.005));
    }

    SECTION("Testing dir(3, 3, 3) prior with optimizing") {
        std::vector<double> alphas = {3.0, 3.0, 3.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RelativePopulationSizeMixer>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        std::vector<double> expected_means = dir_prior.get_mean();
        for (unsigned int i = 0; i < expected_means.size(); ++i) {
            expected_means.at(i) *= (double)nnodes;
        }
        std::vector<double> expected_variances = dir_prior.get_variance();
        for (unsigned int i = 0; i < expected_variances.size(); ++i) {
            expected_variances.at(i) *= ((double)nnodes * (double)nnodes);
        }

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_multipliers();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(expected_means.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.mean() == Approx(expected_means.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.mean() == Approx(expected_means.at(1)).epsilon(0.001));

        REQUIRE(multiplier_root_summary.variance() == Approx(expected_variances.at(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(expected_variances.at(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(expected_variances.at(1)).epsilon(0.005));
    }
}

TEST_CASE("Testing RelativePopulationSizeMixer for dirichlet(10, 10, 10)", "[RelativePopulationSizeMixer]") {

    SECTION("Testing dir(10, 10, 10) prior and no optimizing") {
        std::vector<double> alphas = {10.0, 10.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RelativePopulationSizeMixer>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        std::vector<double> expected_means = dir_prior.get_mean();
        for (unsigned int i = 0; i < expected_means.size(); ++i) {
            expected_means.at(i) *= (double)nnodes;
        }
        std::vector<double> expected_variances = dir_prior.get_variance();
        for (unsigned int i = 0; i < expected_variances.size(); ++i) {
            expected_variances.at(i) *= ((double)nnodes * (double)nnodes);
        }

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_multipliers();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(expected_means.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.mean() == Approx(expected_means.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.mean() == Approx(expected_means.at(1)).epsilon(0.001));

        REQUIRE(multiplier_root_summary.variance() == Approx(expected_variances.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.variance() == Approx(expected_variances.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.variance() == Approx(expected_variances.at(1)).epsilon(0.001));
    }

    SECTION("Testing dir(10, 10, 10) prior with optimizing") {
        std::vector<double> alphas = {10.0, 10.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RelativePopulationSizeMixer>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        std::vector<double> expected_means = dir_prior.get_mean();
        for (unsigned int i = 0; i < expected_means.size(); ++i) {
            expected_means.at(i) *= (double)nnodes;
        }
        std::vector<double> expected_variances = dir_prior.get_variance();
        for (unsigned int i = 0; i < expected_variances.size(); ++i) {
            expected_variances.at(i) *= ((double)nnodes * (double)nnodes);
        }

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_multipliers();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(expected_means.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.mean() == Approx(expected_means.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.mean() == Approx(expected_means.at(1)).epsilon(0.001));

        REQUIRE(multiplier_root_summary.variance() == Approx(expected_variances.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.variance() == Approx(expected_variances.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.variance() == Approx(expected_variances.at(1)).epsilon(0.001));
    }
}

TEST_CASE("Testing RelativePopulationSizeMixer for dirichlet(15, 5, 20)", "[RelativePopulationSizeMixer]") {

    SECTION("Testing dir(15, 5, 20) prior and no optimizing") {
        std::vector<double> alphas = {15.0, 5.0, 20.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RelativePopulationSizeMixer>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_off_auto_optimize();
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        std::vector<double> expected_means = dir_prior.get_mean();
        for (unsigned int i = 0; i < expected_means.size(); ++i) {
            expected_means.at(i) *= (double)nnodes;
        }
        std::vector<double> expected_variances = dir_prior.get_variance();
        for (unsigned int i = 0; i < expected_variances.size(); ++i) {
            expected_variances.at(i) *= ((double)nnodes * (double)nnodes);
        }

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_multipliers();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(expected_means.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.mean() == Approx(expected_means.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.mean() == Approx(expected_means.at(1)).epsilon(0.001));

        REQUIRE(multiplier_root_summary.variance() == Approx(expected_variances.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.variance() == Approx(expected_variances.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.variance() == Approx(expected_variances.at(1)).epsilon(0.001));
    }

    SECTION("Testing dir(15, 5, 20) prior with optimizing") {
        std::vector<double> alphas = {15.0, 5.0, 20.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<RelativePopulationSizeMixer>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        std::vector<double> expected_means = dir_prior.get_mean();
        for (unsigned int i = 0; i < expected_means.size(); ++i) {
            expected_means.at(i) *= (double)nnodes;
        }
        std::vector<double> expected_variances = dir_prior.get_variance();
        for (unsigned int i = 0; i < expected_variances.size(); ++i) {
            expected_variances.at(i) *= ((double)nnodes * (double)nnodes);
        }

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_multipliers();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(expected_means.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.mean() == Approx(expected_means.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.mean() == Approx(expected_means.at(1)).epsilon(0.001));

        REQUIRE(multiplier_root_summary.variance() == Approx(expected_variances.at(2)).epsilon(0.001));
        REQUIRE(multiplier_0_summary.variance() == Approx(expected_variances.at(0)).epsilon(0.001));
        REQUIRE(multiplier_1_summary.variance() == Approx(expected_variances.at(1)).epsilon(0.001));
    }
}

TEST_CASE("Testing UnivariateTimeMeanSizeRateScaler for dirichlet trees",
        "[UnivariateTimeMeanSizeRateScaler]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << size_shape << "\n";
        out << "                    scale: " << size_scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<UnivariateTimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(size_shape * size_scale).epsilon(0.005));
        REQUIRE(size_summary.variance() == Approx(size_shape * size_scale * size_scale).epsilon(0.005));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));
    }
}

TEST_CASE("Testing UnivariateTimeMeanSizeRateScaler with height only",
        "[UnivariateTimeMeanSizeRateScaler]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<UnivariateTimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(1.0));
        REQUIRE(size_summary.variance() == Approx(0.0));
        REQUIRE(rate_summary.mean() == Approx(1.0));
        REQUIRE(rate_summary.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing UnivariateTimeMeanSizeRateScaler with no size",
        "[UnivariateTimeMeanSizeRateScaler]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<UnivariateTimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(0.5));
        REQUIRE(size_summary.variance() == Approx(0.0));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));
    }
}

TEST_CASE("Testing UnivariateTimeMeanSizeRateScaler with no rate",
        "[UnivariateTimeMeanSizeRateScaler]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << size_shape << "\n";
        out << "                    scale: " << size_scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<UnivariateTimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(size_shape * size_scale).epsilon(0.005));
        REQUIRE(size_summary.variance() == Approx(size_shape * size_scale * size_scale).epsilon(0.005));

        REQUIRE(rate_summary.mean() == Approx(1.0));
        REQUIRE(rate_summary.variance() == Approx(0.0));
    }
}


TEST_CASE("Testing UnivariateCompositeTimeMeanSizeRateScaler for dirichlet trees",
        "[UnivariateCompositeTimeMeanSizeRateScaler]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << size_shape << "\n";
        out << "                    scale: " << size_scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<UnivariateCompositeTimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(size_shape * size_scale).epsilon(0.005));
        REQUIRE(size_summary.variance() == Approx(size_shape * size_scale * size_scale).epsilon(0.005));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));
    }
}

TEST_CASE("Testing UnivariateCompositeTimeMeanSizeRateScaler with height only",
        "[UnivariateCompositeTimeMeanSizeRateScaler]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<UnivariateCompositeTimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(1.0));
        REQUIRE(size_summary.variance() == Approx(0.0));
        REQUIRE(rate_summary.mean() == Approx(1.0));
        REQUIRE(rate_summary.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing UnivariateCompositeTimeMeanSizeRateScaler with no size",
        "[UnivariateCompositeTimeMeanSizeRateScaler]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<UnivariateCompositeTimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(0.5));
        REQUIRE(size_summary.variance() == Approx(0.0));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));
    }
}

TEST_CASE("Testing UnivariateCompositeTimeMeanSizeRateScaler with no rate",
        "[UnivariateCompositeTimeMeanSizeRateScaler]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << size_shape << "\n";
        out << "                    scale: " << size_scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<UnivariateCompositeTimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(size_shape * size_scale).epsilon(0.005));
        REQUIRE(size_summary.variance() == Approx(size_shape * size_scale * size_scale).epsilon(0.005));

        REQUIRE(rate_summary.mean() == Approx(1.0));
        REQUIRE(rate_summary.variance() == Approx(0.0));
    }
}


TEST_CASE("Testing TimeMeanSizeRateMixer for dirichlet trees",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << size_shape << "\n";
        out << "                    scale: " << size_scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(1000);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                std::vector<double> sizes = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                multiplier_root_summary.add_sample(sizes.at(sizes.size() - 1));
                multiplier_0_summary.add_sample(sizes.at(0));
                multiplier_1_summary.add_sample(sizes.at(1));
            }
        }

        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(size_shape * size_scale).epsilon(0.005));
        REQUIRE(size_summary.variance() == Approx(size_shape * size_scale * size_scale).epsilon(0.005));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with height only",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        std::cout << op->header_string();
        std::cout << op->to_string(os);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(1.0));
        REQUIRE(size_summary.variance() == Approx(0.0));
        REQUIRE(rate_summary.mean() == Approx(1.0));
        REQUIRE(rate_summary.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with no size",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(1000);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(0.5));
        REQUIRE(size_summary.variance() == Approx(0.0));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with no mean size",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(1000);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                std::vector<double> sizes = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                multiplier_root_summary.add_sample(sizes.at(sizes.size() - 1));
                multiplier_0_summary.add_sample(sizes.at(0));
                multiplier_1_summary.add_sample(sizes.at(1));
            }
        }

        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(0.005));
        REQUIRE(size_summary.variance() == Approx(0.0));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with no rate",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << size_shape << "\n";
        out << "                    scale: " << size_scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(1000);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                std::vector<double> sizes = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                multiplier_root_summary.add_sample(sizes.at(sizes.size() - 1));
                multiplier_0_summary.add_sample(sizes.at(0));
                multiplier_1_summary.add_sample(sizes.at(1));
            }
        }

        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(size_shape * size_scale).epsilon(0.005));
        REQUIRE(size_summary.variance() == Approx(size_shape * size_scale * size_scale).epsilon(0.005));

        REQUIRE(rate_summary.mean() == Approx(1.0));
        REQUIRE(rate_summary.variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}


TEST_CASE("Testing TimeMeanSizeRateMixer with 4 pairs",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with 4 pairs and fixed sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with 4 pairs and fixed multipliers",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed multipliers") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with 4 pairs and fixed mean sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed mean sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(334444);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
        }
    }
}


TEST_CASE("Testing TimeMeanSizeRateMixer with 4 singletons",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(1234);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}


TEST_CASE("Testing TimeMeanSizeRateMixer with 4 pairs and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing and mix of pair and singletons and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with 4 pairs with fixed sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed sizes shared event optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with 4 pairs and fixed multipliers and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event and fixed multipliers") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with 4 pairs and fixed mean sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event and fixed mean sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
        }
    }
}


TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons with fixed sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(4) << "\n";
        os << "                    scale: " << mu_scales.at(4) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons and fixed multipliers",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed multipliers") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons and fixed mean sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed mean sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons and fixed mean sizes and rates",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed mean sizes and rates") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons with fixed sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing and mix of pair and singletons with fixed sizes and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons and shared event and fixed multipliers",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing and mix of pair and singletons and shared event and fixed multipliers") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons with fixed mean sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing and mix of pair and singletons with fixe mean sizes and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons with fixed mean sizes and rates and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed mean sizes and rates and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons with fixed rates",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed rates") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::vector<double> alphas2 {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test10-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test10-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(4) << "\n";
        os << "                    scale: " << size_scales.at(4) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 1200000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            if (tree_idx < 3) {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            }
            else {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
            }
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons with fixed rates and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed rates and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::vector<double> alphas2 {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test11-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test11-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(4) << "\n";
        os << "                    scale: " << size_scales.at(4) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            if (tree_idx < 3) {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            }
            else {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
            }
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons with fixed rates and mean sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed rates and mean sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::vector<double> alphas2 {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test12-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test12-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            if (tree_idx < 3) {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            }
            else {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
            }
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateMixer with mix of pairs and singletons with fixed rates and mean sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed rates and mean sizes and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::vector<double> alphas2 {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test13-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test13-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            if (tree_idx < 3) {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            }
            else {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
            }
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer for dirichlet trees",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << size_shape << "\n";
        out << "                    scale: " << size_scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(1000);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                std::vector<double> sizes = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                multiplier_root_summary.add_sample(sizes.at(sizes.size() - 1));
                multiplier_0_summary.add_sample(sizes.at(0));
                multiplier_1_summary.add_sample(sizes.at(1));
            }
        }

        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(size_shape * size_scale).epsilon(0.005));
        REQUIRE(size_summary.variance() == Approx(size_shape * size_scale * size_scale).epsilon(0.005));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with height only",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(1000);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
        }

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(1.0));
        REQUIRE(size_summary.variance() == Approx(0.0));
        REQUIRE(rate_summary.mean() == Approx(1.0));
        REQUIRE(rate_summary.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with no size",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.5;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            value: [1.0, 1.0, 1.0]\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(1000);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
            }
        }

        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(0.5));
        REQUIRE(size_summary.variance() == Approx(0.0));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with no mean size",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(1000);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                std::vector<double> sizes = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                multiplier_root_summary.add_sample(sizes.at(sizes.size() - 1));
                multiplier_0_summary.add_sample(sizes.at(0));
                multiplier_1_summary.add_sample(sizes.at(1));
            }
        }

        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(0.005));
        REQUIRE(size_summary.variance() == Approx(0.0));

        REQUIRE(rate_summary.mean() == Approx(rate_shape * rate_scale).epsilon(0.005));
        REQUIRE(rate_summary.variance() == Approx(rate_shape * rate_scale * rate_scale).epsilon(0.005));

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with no rate",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing with optimizing") {
        double height_shape = 10.0;
        double height_scale = 0.1;
        double size_shape = 5.0;
        double size_scale = 0.01;
        double rate_shape = 4.0;
        double rate_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << height_shape << "\n";
        out << "        scale: " << height_scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << size_shape << "\n";
        out << "                    scale: " << size_scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << rate_shape << "\n";
        out << "                    scale: " << rate_scale << "\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(1000);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary;
        SampleSummarizer<double> rate_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_height(0));
                size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                rate_summary.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                std::vector<double> sizes = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                multiplier_root_summary.add_sample(sizes.at(sizes.size() - 1));
                multiplier_0_summary.add_sample(sizes.at(0));
                multiplier_1_summary.add_sample(sizes.at(1));
            }
        }

        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(size_summary.sample_size() == nsamples);
        REQUIRE(rate_summary.sample_size() == nsamples);

        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.005));

        REQUIRE(size_summary.mean() == Approx(size_shape * size_scale).epsilon(0.005));
        REQUIRE(size_summary.variance() == Approx(size_shape * size_scale * size_scale).epsilon(0.005));

        REQUIRE(rate_summary.mean() == Approx(1.0));
        REQUIRE(rate_summary.variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}


TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with 4 pairs",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with 4 pairs and fixed sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with 4 pairs and fixed multipliers",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed multipliers") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with 4 pairs and fixed mean sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed mean sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(334444);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
        }
    }
}


TEST_CASE("Testing tree-specfic TimeMeanSizeRateMixer with 4 singletons",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test3-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test3-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(1234);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}


TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with 4 pairs and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing and mix of pair and singletons and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with 4 pairs with fixed sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with fixed sizes shared event optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with 4 pairs and fixed multipliers and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event and fixed multipliers") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(1.0/3.0));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with 4 pairs and fixed mean sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with shared event and fixed mean sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_1_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                    multiplier_1_summary.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

            REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_1_summary.at(tree_idx).sample_size() == nsamples);
            REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
            REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
            REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            REQUIRE(multiplier_1_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
        }
    }
}


TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons with fixed sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(4) << "\n";
        os << "                    scale: " << mu_scales.at(4) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons and fixed multipliers",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed multipliers") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons and fixed mean sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed mean sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons and fixed mean sizes and rates",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed mean sizes and rates") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons with fixed sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing and mix of pair and singletons with fixed sizes and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons and shared event and fixed multipliers",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing and mix of pair and singletons and shared event and fixed multipliers") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 2.0]\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        size_sh = size_shapes.at(tree_idx);
        size_sc = size_scales.at(tree_idx);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        size_sh = size_shapes.at(tree_idx - 1);
        size_sc = size_scales.at(tree_idx - 1);
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(2.0/3.0));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(1.0/3.0));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons with fixed mean sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing 4 pairs with optimizing and mix of pair and singletons with fixe mean sizes and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        mu_sh = mu_shapes.at(tree_idx - 1);
        mu_sc = mu_scales.at(tree_idx - 1);
        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons with fixed mean sizes and rates and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed mean sizes and rates and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::vector<double> alphas2 = {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        unsigned int tree_idx = 0;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
    
        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 2;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        tree_idx = 3;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));

        tree_idx = 4;
        REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
        REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));

        REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons with fixed rates",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed rates") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::vector<double> alphas2 {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test10-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test10-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(4) << "\n";
        os << "                    scale: " << size_scales.at(4) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 1200000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            if (tree_idx < 3) {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            }
            else {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
            }
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons with fixed rates and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed rates and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::vector<double> alphas2 {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test11-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test11-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(4) << "\n";
        os << "                    scale: " << size_scales.at(4) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            if (tree_idx < 3) {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            }
            else {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
            }
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons with fixed rates and mean sizes",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed rates and mean sizes") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::vector<double> alphas2 {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test12-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test12-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            if (tree_idx < 3) {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            }
            else {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
            }
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateMixer with mix of pairs and singletons with fixed rates and mean sizes and shared event",
        "[TimeMeanSizeRateMixer]") {

    SECTION("Testing mix of pair and singletons with fixed rates and mean sizes and shared event") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0, 7.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5, 0.15};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0, 7.5};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05, 0.1};
        std::vector<double> alphas {5.0, 10.0, 15.0};
        std::vector<double> alphas2 {5.0, 10.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-timemeansizeratemixer-test13-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-timemeansizeratemixer-test13-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas2.at(0);
        for (unsigned int i = 1; i < alphas2.size(); ++i) {
            os << ", " << alphas2.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateMixer>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<RelativePopulationSizeMixer>(i, 1.0, 0.01));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_root_summary(ntrees);
        std::vector< SampleSummarizer<double> > multiplier_0_summary(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);
        DirichletDistribution dir_prior2 = DirichletDistribution(alphas2);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                    mutation_rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    multiplier_root_summary.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    multiplier_0_summary.at(tree_idx).add_sample(sizes.at(0));
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));

            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            if (tree_idx < 3) {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
            }
            else {
                REQUIRE(multiplier_root_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_root_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(1)).epsilon(0.005));
                REQUIRE(multiplier_root_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(1)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).sample_size() == nsamples);
                REQUIRE(multiplier_0_summary.at(tree_idx).mean() == Approx(dir_prior2.get_mean(0)).epsilon(0.005));
                REQUIRE(multiplier_0_summary.at(tree_idx).variance() == Approx(dir_prior2.get_variance(0)).epsilon(0.005));
            }
        }
    }
}


TEST_CASE("Testing TimeMeanSizeRateScaler with 4 pairs",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_root = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with 4 pairs with fixed mean sizes",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed mean sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}


TEST_CASE("Testing TimeMeanSizeRateScaler with 4 singletons",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with mix of pairs and singletons",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_summary_pair1;
        SampleSummarizer<double> size_summary_pair2;
        SampleSummarizer<double> size_summary_pair3;
        SampleSummarizer<double> size_summary_single1;
        SampleSummarizer<double> size_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_pair1 = comparisons.get_tree(0)->get_mean_population_size();

                double  size_pair2 = comparisons.get_tree(1)->get_mean_population_size();

                double  size_pair3 = comparisons.get_tree(2)->get_mean_population_size();

                double size_single1 = comparisons.get_tree(3)->get_mean_population_size();

                double size_single2 = comparisons.get_tree(4)->get_mean_population_size();

                size_summary_pair1.add_sample(size_pair1);
                size_summary_pair2.add_sample(size_pair2);
                size_summary_pair3.add_sample(size_pair3);
                size_summary_single1.add_sample(size_single1);
                size_summary_single2.add_sample(size_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with 4 pairs and shared event",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(33333);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with mix of pairs and singletons and shared event",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary_pair1;
        SampleSummarizer<double> size_summary_pair2;
        SampleSummarizer<double> size_summary_pair3;
        SampleSummarizer<double> size_summary_single1;
        SampleSummarizer<double> size_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_pair1 = comparisons.get_tree(0)->get_mean_population_size();

                double  size_pair2 = comparisons.get_tree(1)->get_mean_population_size();

                double  size_pair3 = comparisons.get_tree(2)->get_mean_population_size();

                double size_single1 = comparisons.get_tree(3)->get_mean_population_size();

                double size_single2 = comparisons.get_tree(4)->get_mean_population_size();

                size_summary_pair1.add_sample(size_pair1);
                size_summary_pair2.add_sample(size_pair2);
                size_summary_pair3.add_sample(size_pair3);
                size_summary_single1.add_sample(size_single1);
                size_summary_single2.add_sample(size_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with 4 pairs with fixed mean sizes and shared event",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed mean sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with 4 pairs and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test9-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test9-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with 4 pairs with fixed mean sizes and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed mean sizes and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test10-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test10-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        std::cout << op->header_string();
        std::cout << op->to_string(op_schedule);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}


TEST_CASE("Testing TimeMeanSizeRateScaler with 4 singletons and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 singletons and fixed rates with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test12-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test12-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(2222);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with mix of pairs and singletons and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test13-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test13-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_summary_pair1;
        SampleSummarizer<double> size_summary_pair2;
        SampleSummarizer<double> size_summary_pair3;
        SampleSummarizer<double> size_summary_single1;
        SampleSummarizer<double> size_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_pair1 = comparisons.get_tree(0)->get_mean_population_size();

                double  size_pair2 = comparisons.get_tree(1)->get_mean_population_size();

                double  size_pair3 = comparisons.get_tree(2)->get_mean_population_size();

                double size_single1 = comparisons.get_tree(3)->get_mean_population_size();

                double size_single2 = comparisons.get_tree(4)->get_mean_population_size();

                size_summary_pair1.add_sample(size_pair1);
                size_summary_pair2.add_sample(size_pair2);
                size_summary_pair3.add_sample(size_pair3);
                size_summary_single1.add_sample(size_single1);
                size_summary_single2.add_sample(size_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with 4 pairs and shared event and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test14-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test14-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(9999);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with mix of pairs and singletons and shared event and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test15-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test15-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        op_schedule.add_operator(std::make_shared<EventTimeScaler>(1.0, 0.5));
        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary_pair1;
        SampleSummarizer<double> size_summary_pair2;
        SampleSummarizer<double> size_summary_pair3;
        SampleSummarizer<double> size_summary_single1;
        SampleSummarizer<double> size_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            op->operate(rng, &comparisons, 1);
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_pair1 = comparisons.get_tree(0)->get_mean_population_size();

                double  size_pair2 = comparisons.get_tree(1)->get_mean_population_size();

                double  size_pair3 = comparisons.get_tree(2)->get_mean_population_size();

                double size_single1 = comparisons.get_tree(3)->get_mean_population_size();

                double size_single2 = comparisons.get_tree(4)->get_mean_population_size();

                size_summary_pair1.add_sample(size_pair1);
                size_summary_pair2.add_sample(size_pair2);
                size_summary_pair3.add_sample(size_pair3);
                size_summary_single1.add_sample(size_single1);
                size_summary_single2.add_sample(size_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing TimeMeanSizeRateScaler with 4 pairs with fixed mean sizes and shared event and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed mean sizes and shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test16-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test16-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.5);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);
        op_schedule.add_operator(op);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        std::cout << op->header_string();
        std::cout << op->to_string(op_schedule);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}


TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with 4 pairs",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size_root;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size_root = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_root_summaries.at(tree_idx).add_sample(size_root);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_root_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_root_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_root_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specfic TimeMeanSizeRateScaler with 4 pairs with fixed mean sizes",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed mean sizes and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test2-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test2-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}


TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with 4 singletons",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test4-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test4-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with mix of pairs and singletons",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test5-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test5-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_summary_pair1;
        SampleSummarizer<double> size_summary_pair2;
        SampleSummarizer<double> size_summary_pair3;
        SampleSummarizer<double> size_summary_single1;
        SampleSummarizer<double> size_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_pair1 = comparisons.get_tree(0)->get_mean_population_size();

                double  size_pair2 = comparisons.get_tree(1)->get_mean_population_size();

                double  size_pair3 = comparisons.get_tree(2)->get_mean_population_size();

                double size_single1 = comparisons.get_tree(3)->get_mean_population_size();

                double size_single2 = comparisons.get_tree(4)->get_mean_population_size();

                size_summary_pair1.add_sample(size_pair1);
                size_summary_pair2.add_sample(size_pair2);
                size_summary_pair3.add_sample(size_pair3);
                size_summary_single1.add_sample(size_single1);
                size_summary_single2.add_sample(size_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with 4 pairs and shared event",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test6-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test6-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(33333);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with mix of pairs and singletons and shared event",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test7-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test7-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary_pair1;
        SampleSummarizer<double> size_summary_pair2;
        SampleSummarizer<double> size_summary_pair3;
        SampleSummarizer<double> size_summary_single1;
        SampleSummarizer<double> size_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_pair1 = comparisons.get_tree(0)->get_mean_population_size();

                double  size_pair2 = comparisons.get_tree(1)->get_mean_population_size();

                double  size_pair3 = comparisons.get_tree(2)->get_mean_population_size();

                double size_single1 = comparisons.get_tree(3)->get_mean_population_size();

                double size_single2 = comparisons.get_tree(4)->get_mean_population_size();

                size_summary_pair1.add_sample(size_pair1);
                size_summary_pair2.add_sample(size_pair2);
                size_summary_pair3.add_sample(size_pair3);
                size_summary_single1.add_sample(size_single1);
                size_summary_single2.add_sample(size_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));

        double mu_sh = mu_shapes.at(0);
        double mu_sc = mu_scales.at(0);
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(1);
        mu_sc = mu_scales.at(1);
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(2);
        mu_sc = mu_scales.at(2);
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));

        mu_sh = mu_shapes.at(3);
        mu_sc = mu_scales.at(3);
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(mu_sh * mu_sc).epsilon(0.01));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with 4 pairs with fixed mean sizes and shared event",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed mean sizes and shared event and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> mu_shapes {5.0, 3.0, 4.0, 10.0};
        std::vector<double> mu_scales {0.15, 0.2, 0.25, 0.05};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test8-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test8-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(0) << "\n";
        os << "                    scale: " << mu_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(1) << "\n";
        os << "                    scale: " << mu_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(2) << "\n";
        os << "                    scale: " << mu_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << mu_shapes.at(3) << "\n";
        os << "                    scale: " << mu_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MutationRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        double mu_sh;
        double mu_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            mu_sh = mu_shapes.at(tree_idx);
            mu_sc = mu_scales.at(tree_idx);
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(mu_sh * mu_sc).epsilon(0.005));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(mu_sh * mu_sc * mu_sc).epsilon(0.01));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with 4 pairs and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test9-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test9-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with 4 pairs with fixed mean sizes and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed mean sizes and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test10-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test10-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 500000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}


TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with 4 singletons and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 singletons and fixed rates with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test12-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test12-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(2222);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        std::vector< SampleSummarizer<double> > height_summaries(ntrees);
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == ntrees);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    height_summaries.at(tree_idx).add_sample(tree->get_root_height());
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(height_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(height_summaries.at(tree_idx).mean() == Approx(height_shape * height_scale).epsilon(0.005));
            REQUIRE(height_summaries.at(tree_idx).variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with mix of pairs and singletons and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test13-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test13-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == ntrees);
        SampleSummarizer<double> height_summary_pair1;
        SampleSummarizer<double> height_summary_pair2;
        SampleSummarizer<double> height_summary_pair3;
        SampleSummarizer<double> height_summary_single1;
        SampleSummarizer<double> height_summary_single2;
        SampleSummarizer<double> size_summary_pair1;
        SampleSummarizer<double> size_summary_pair2;
        SampleSummarizer<double> size_summary_pair3;
        SampleSummarizer<double> size_summary_single1;
        SampleSummarizer<double> size_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == ntrees);

                height_summary_pair1.add_sample(comparisons.get_tree(0)->get_root_height());
                height_summary_pair2.add_sample(comparisons.get_tree(1)->get_root_height());
                height_summary_pair3.add_sample(comparisons.get_tree(2)->get_root_height());
                height_summary_single1.add_sample(comparisons.get_tree(3)->get_root_height());
                height_summary_single2.add_sample(comparisons.get_tree(4)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_pair1 = comparisons.get_tree(0)->get_mean_population_size();

                double  size_pair2 = comparisons.get_tree(1)->get_mean_population_size();

                double  size_pair3 = comparisons.get_tree(2)->get_mean_population_size();

                double size_single1 = comparisons.get_tree(3)->get_mean_population_size();

                double size_single2 = comparisons.get_tree(4)->get_mean_population_size();

                size_summary_pair1.add_sample(size_pair1);
                size_summary_pair2.add_sample(size_pair2);
                size_summary_pair3.add_sample(size_pair3);
                size_summary_single1.add_sample(size_single1);
                size_summary_single2.add_sample(size_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary_pair1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_pair3.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_pair3.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single1.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single1.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        REQUIRE(height_summary_single2.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary_single2.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with 4 pairs and shared event and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test14-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test14-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(9999);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            size_sh = size_shapes.at(tree_idx);
            size_sc = size_scales.at(tree_idx);
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(size_sh * size_sc).epsilon(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with mix of pairs and singletons and shared event and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing mix of pairs and singletons with shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 2.0, 5.0, 4.0};
        std::vector<double> size_scales {0.1, 0.2, 0.2, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test15-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test15-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 0.01\n";
        os << "            estimate: false\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname4-singleton.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(3) << "\n";
        os << "                    scale: " << size_scales.at(3) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
            op_schedule.add_operator(std::make_shared<MeanPopulationSizeScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 5);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        SampleSummarizer<double> size_summary_pair1;
        SampleSummarizer<double> size_summary_pair2;
        SampleSummarizer<double> size_summary_pair3;
        SampleSummarizer<double> size_summary_single1;
        SampleSummarizer<double> size_summary_single2;
        SampleSummarizer<double> mutation_rate_summary_pair1;
        SampleSummarizer<double> mutation_rate_summary_pair2;
        SampleSummarizer<double> mutation_rate_summary_pair3;
        SampleSummarizer<double> mutation_rate_summary_single1;
        SampleSummarizer<double> mutation_rate_summary_single2;

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 3;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(comparisons.get_number_of_events() == 1);

                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());

                mutation_rate_summary_pair1.add_sample(comparisons.get_tree(0)->get_mutation_rate());
                mutation_rate_summary_pair2.add_sample(comparisons.get_tree(1)->get_mutation_rate());
                mutation_rate_summary_pair3.add_sample(comparisons.get_tree(2)->get_mutation_rate());
                mutation_rate_summary_single1.add_sample(comparisons.get_tree(3)->get_mutation_rate());
                mutation_rate_summary_single2.add_sample(comparisons.get_tree(4)->get_mutation_rate());

                double  size_pair1 = comparisons.get_tree(0)->get_mean_population_size();

                double  size_pair2 = comparisons.get_tree(1)->get_mean_population_size();

                double  size_pair3 = comparisons.get_tree(2)->get_mean_population_size();

                double size_single1 = comparisons.get_tree(3)->get_mean_population_size();

                double size_single2 = comparisons.get_tree(4)->get_mean_population_size();

                size_summary_pair1.add_sample(size_pair1);
                size_summary_pair2.add_sample(size_pair2);
                size_summary_pair3.add_sample(size_pair3);
                size_summary_single1.add_sample(size_single1);
                size_summary_single2.add_sample(size_single2);
            }
        }
        op_schedule.write_operator_rates(std::cout);
        
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.01));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));

        double size_sh = size_shapes.at(0);
        double size_sc = size_scales.at(0);
        REQUIRE(size_summary_pair1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(1);
        size_sc = size_scales.at(1);
        REQUIRE(size_summary_pair2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_pair2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(size_summary_pair3.mean() == Approx(0.01));
        REQUIRE(size_summary_pair3.variance() == Approx(0.0));

        size_sh = size_shapes.at(2);
        size_sc = size_scales.at(2);
        REQUIRE(size_summary_single1.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single1.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        size_sh = size_shapes.at(3);
        size_sc = size_scales.at(3);
        REQUIRE(size_summary_single2.mean() == Approx(size_sh * size_sc).epsilon(0.01));
        REQUIRE(size_summary_single2.variance() == Approx(size_sh * size_sc * size_sc).epsilon(0.01));

        REQUIRE(mutation_rate_summary_pair1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair2.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_pair3.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_pair3.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single1.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single1.variance() == Approx(0.0));
        REQUIRE(mutation_rate_summary_single2.mean() == Approx(1.0));
        REQUIRE(mutation_rate_summary_single2.variance() == Approx(0.0));
    }
}

TEST_CASE("Testing tree-specific TimeMeanSizeRateScaler with 4 pairs with fixed mean sizes and shared event and fixed rates",
        "[TimeMeanSizeRateScaler]") {

    SECTION("Testing 4 pairs with fixed mean sizes and shared event and fixed rates and optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-compositetimemeansizeratescaler-test16-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-compositetimemeansizeratescaler-test16-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_model_prior:\n";
        os << "    fixed: [0, 0, 0, 0]\n";
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname3.nex\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        for (unsigned int i = 0; i < comparisons.get_number_of_trees(); ++i) {
            op_schedule.add_operator(std::make_shared<TimeMeanSizeRateScaler>(i, 1.0, 0.5));
        }

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 4);
        REQUIRE(comparisons.get_number_of_events() == 1);
        SampleSummarizer<double> height_summary;
        std::vector< SampleSummarizer<double> > size_summaries(ntrees);
        std::vector< SampleSummarizer<double> > mutation_rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        double size;
        double mutation_rate;
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            for (std::shared_ptr<OperatorInterface> op : comparisons.get_multivariate_time_operators()) {
                op->operate(rng, &comparisons, 1);
            }
            if ((i + 1) % sample_freq == 0) {
                height_summary.add_sample(comparisons.get_tree(0)->get_root_height());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    REQUIRE(comparisons.get_number_of_events() == 1);
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size = tree->get_mean_population_size();
                    mutation_rate = tree->get_mutation_rate();
                    size_summaries.at(tree_idx).add_sample(size);
                    mutation_rate_summaries.at(tree_idx).add_sample(mutation_rate);
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        REQUIRE(height_summary.sample_size() == nsamples);
        REQUIRE(height_summary.mean() == Approx(height_shape * height_scale).epsilon(0.005));
        REQUIRE(height_summary.variance() == Approx(height_shape * height_scale * height_scale).epsilon(0.01));
        
        double size_sh;
        double size_sc;
        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(size_summaries.at(tree_idx).mean() == Approx(0.005));
            REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(mutation_rate_summaries.at(tree_idx).mean() == Approx(1.0));
            REQUIRE(mutation_rate_summaries.at(tree_idx).variance() == Approx(0.0));
        }
    }
}

TEST_CASE("Testing RelativePopulationSizeMovers for dirichlet(1, 1, 1)", "[RelativePopulationSizeMovers]") {

    SECTION("Testing dir(1, 1, 1) prior with optimizing") {
        std::vector<double> alphas = {1.0, 1.0, 1.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op1 = std::make_shared<RootRelativePopulationSizeMover>(1.0, 0.01);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<LeafRelativePopulationSizeMover>(1.0, 0.01);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op1);
        os.add_operator(op2);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> mean_size_summary;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                mean_size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op1->header_string();
        std::cout << op1->to_string(os);
        std::cout << op2->to_string(os);

        REQUIRE(mean_size_summary.sample_size() == nsamples);
        REQUIRE(mean_size_summary.mean() == Approx(0.005));
        REQUIRE(mean_size_summary.variance() == Approx(0.0));

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));

        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}

TEST_CASE("Testing RelativePopulationSizeMovers for dirichlet(1, 1, 1) and gamma(10, 0.1)",
        "[RelativePopulationSizeMovers]") {

    SECTION("Testing dir(1, 1, 1) and gamma(10, 0.1) prior with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::vector<double> alphas = {1.0, 1.0, 1.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op1 = std::make_shared<RootRelativePopulationSizeMover>(1.0, 0.5);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<LeafRelativePopulationSizeMover>(1.0, 0.5);
        std::shared_ptr<OperatorInterface> op3 = std::make_shared<MeanPopulationSizeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op1);
        os.add_operator(op2);
        os.add_operator(op3);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> mean_size_summary;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                mean_size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op1->header_string();
        std::cout << op1->to_string(os);
        std::cout << op2->to_string(os);
        std::cout << op3->to_string(os);

        REQUIRE(mean_size_summary.sample_size() == nsamples);
        REQUIRE(mean_size_summary.mean() == Approx(shape * scale).epsilon(0.005));
        REQUIRE(mean_size_summary.variance() == Approx(shape * scale * scale).epsilon(0.005));

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));

        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}


TEST_CASE("Testing RelativePopulationSizeMovers for dirichlet(10, 15, 5) and gamma(10, 0.1)",
        "[RelativePopulationSizeMovers]") {

    SECTION("Testing dir(10, 15, 5) and gamma(10, 0.1) prior with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::vector<double> alphas = {10.0, 15.0, 5.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op1 = std::make_shared<RootRelativePopulationSizeMover>(1.0, 0.5);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<LeafRelativePopulationSizeMover>(1.0, 0.5);
        std::shared_ptr<OperatorInterface> op3 = std::make_shared<MeanPopulationSizeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op1);
        os.add_operator(op2);
        os.add_operator(op3);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> mean_size_summary;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;
        SampleSummarizer<double> multiplier_1_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                double multiplier_root = multipliers.at(2);
                double multiplier_0 = multipliers.at(0);
                double multiplier_1 = multipliers.at(1);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                multiplier_1_summary.add_sample(multiplier_1);
                mean_size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                    REQUIRE(multiplier_root != multiplier_1);
                    REQUIRE(multiplier_0 != multiplier_1);
                }
            }
        }

        std::cout << op1->header_string();
        std::cout << op1->to_string(os);
        std::cout << op2->to_string(os);
        std::cout << op3->to_string(os);

        REQUIRE(mean_size_summary.sample_size() == nsamples);
        REQUIRE(mean_size_summary.mean() == Approx(shape * scale).epsilon(0.005));
        REQUIRE(mean_size_summary.variance() == Approx(shape * scale * scale).epsilon(0.005));

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);
        REQUIRE(multiplier_1_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));

        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
        REQUIRE(multiplier_1_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}

TEST_CASE("Testing RelativePopulationSizeMovers for singleton with dirichlet(10, 15, 5) and gamma(10, 0.1)",
        "[RelativePopulationSizeMovers]") {

    SECTION("Testing dir(10, 15, 5) and gamma(10, 0.1) prior with singleton and optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::vector<double> alphas = {10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                gamma_distribution:\n";
        out << "                    shape: " << shape << "\n";
        out << "                    scale: " << scale << "\n";
        out << "        population_size_multipliers:\n";
        out << "            estimate: true\n";
        out << "            prior:\n";
        out << "                dirichlet_distribution:\n";
        out << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            out << ", " << alphas.at(i);
        }
        out << "]\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129-singleton.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(12345);
        std::shared_ptr<OperatorInterface> op1 = std::make_shared<RootRelativePopulationSizeMover>(1.0, 0.5);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<LeafRelativePopulationSizeMover>(1.0, 0.5);
        std::shared_ptr<OperatorInterface> op3 = std::make_shared<MeanPopulationSizeScaler>(1.0, 0.5);
        OperatorSchedule os = OperatorSchedule();
        os.turn_on_auto_optimize();
        os.set_auto_optimize_delay(1000);
        os.add_operator(op1);
        os.add_operator(op2);
        os.add_operator(op3);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int nnodes = 3;
        SampleSummarizer<double> mean_size_summary;
        SampleSummarizer<double> multiplier_root_summary;
        SampleSummarizer<double> multiplier_0_summary;

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(os);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 2;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = os.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                std::vector<double> multipliers = comparisons.get_tree(0)->get_population_sizes_as_proportions();
                double multiplier_root = multipliers.at(1);
                double multiplier_0 = multipliers.at(0);
                multiplier_root_summary.add_sample(multiplier_root);
                multiplier_0_summary.add_sample(multiplier_0);
                mean_size_summary.add_sample(comparisons.get_tree(0)->get_mean_population_size());
                if (i > (niterations - (sample_freq * 10))) {
                    REQUIRE(multiplier_root != multiplier_0);
                }
            }
        }

        std::cout << op1->header_string();
        std::cout << op1->to_string(os);
        std::cout << op2->to_string(os);
        std::cout << op3->to_string(os);

        REQUIRE(mean_size_summary.sample_size() == nsamples);
        REQUIRE(mean_size_summary.mean() == Approx(shape * scale).epsilon(0.005));
        REQUIRE(mean_size_summary.variance() == Approx(shape * scale * scale).epsilon(0.005));

        REQUIRE(multiplier_root_summary.sample_size() == nsamples);
        REQUIRE(multiplier_0_summary.sample_size() == nsamples);

        REQUIRE(multiplier_root_summary.mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));

        REQUIRE(multiplier_root_summary.variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
        REQUIRE(multiplier_0_summary.variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific FreqMover with 3 pairs",
        "[FreqMover]") {

    SECTION("Testing 3 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> freq_alphas {1.0, 1.0, 3.0};
        std::vector<double> freq_betas  {1.0, 3.0, 1.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                beta_distribution:\n";
        os << "                    alpha: " << freq_alphas.at(0) << "\n";
        os << "                    beta: " << freq_betas.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                beta_distribution:\n";
        os << "                    alpha: " << freq_alphas.at(1) << "\n";
        os << "                    beta: " << freq_betas.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                beta_distribution:\n";
        os << "                    alpha: " << freq_alphas.at(2) << "\n";
        os << "                    beta: " << freq_betas.at(2) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        std::shared_ptr<OperatorInterface> op1 = std::make_shared<FreqMover>(0, 1.0, 0.5);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<FreqMover>(2, 1.0, 0.5);
        op_schedule.add_operator(op1);
        op_schedule.add_operator(op2);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        REQUIRE(comparisons.get_number_of_events() == ntrees);

        std::vector< SampleSummarizer<double> > freq_summaries(ntrees);

        std::shared_ptr<ContinuousProbabilityDistribution> prior0 = std::make_shared<BetaDistribution>(freq_alphas.at(0), freq_betas.at(0));
        std::shared_ptr<ContinuousProbabilityDistribution> prior2 = std::make_shared<BetaDistribution>(freq_alphas.at(2), freq_betas.at(2));

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    freq_summaries.at(tree_idx).add_sample(tree->get_freq_1());
                }
            }
        }
        std::cout << op1->header_string();
        std::cout << op1->to_string(op_schedule);
        std::cout << op2->to_string(op_schedule);
        
        unsigned int tree_idx = 0;
        REQUIRE(freq_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(freq_summaries.at(tree_idx).mean() == Approx(prior0->get_mean()).epsilon(0.005));
        REQUIRE(freq_summaries.at(tree_idx).variance() == Approx(prior0->get_variance()).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(freq_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(freq_summaries.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        REQUIRE(freq_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(freq_summaries.at(tree_idx).mean() == Approx(prior2->get_mean()).epsilon(0.005));
        REQUIRE(freq_summaries.at(tree_idx).variance() == Approx(prior2->get_variance()).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific RelativePopulationSizeMixer with 3 pairs",
        "[RelativePopulationSizeMixer]") {

    SECTION("Testing 3 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        std::shared_ptr<OperatorInterface> op1 = std::make_shared<RelativePopulationSizeMixer>(0, 1.0, 0.1);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<RelativePopulationSizeMixer>(2, 1.0, 0.5);
        op_schedule.add_operator(op1);
        op_schedule.add_operator(op2);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        REQUIRE(comparisons.get_number_of_events() == ntrees);

        std::vector< SampleSummarizer<double> > root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > leaf0_summaries(ntrees);
        std::vector< SampleSummarizer<double> > leaf1_summaries(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    root_summaries.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    leaf0_summaries.at(tree_idx).add_sample(sizes.at(0));
                    leaf1_summaries.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        std::cout << op1->header_string();
        std::cout << op1->to_string(op_schedule);
        std::cout << op2->to_string(op_schedule);
        
        unsigned int tree_idx = 0;
        REQUIRE(root_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(root_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(root_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(leaf0_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf0_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(leaf0_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        REQUIRE(leaf1_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf1_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(leaf1_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(root_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(root_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(leaf0_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf0_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(leaf1_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf1_summaries.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        REQUIRE(root_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(root_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(root_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(leaf0_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf0_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(leaf0_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        REQUIRE(leaf1_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf1_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(leaf1_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific MeanPopulationSizeScaler with 3 pairs",
        "[MeanPopulationSizeScaler]") {

    SECTION("Testing 3 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 5.0, 5.0};
        std::vector<double> size_scales {0.1, 0.1, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        std::shared_ptr<OperatorInterface> op1 = std::make_shared<MeanPopulationSizeScaler>(0, 1.0, 0.5);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<MeanPopulationSizeScaler>(2, 1.0, 0.5);
        op_schedule.add_operator(op1);
        op_schedule.add_operator(op2);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        REQUIRE(comparisons.get_number_of_events() == ntrees);

        std::vector< SampleSummarizer<double> > size_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    size_summaries.at(tree_idx).add_sample(tree->get_mean_population_size());
                }
            }
        }
        std::cout << op1->header_string();
        std::cout << op1->to_string(op_schedule);
        std::cout << op2->to_string(op_schedule);
        
        unsigned int tree_idx = 0;
        double sh = size_shapes.at(tree_idx);
        double sc = size_scales.at(tree_idx);

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));

        tree_idx = 1;
        sh = size_shapes.at(tree_idx);
        sc = size_scales.at(tree_idx);

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        sh = size_shapes.at(tree_idx);
        sc = size_scales.at(tree_idx);

        REQUIRE(size_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(size_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(size_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific RelativePopulationSizeMovers with 3 pairs",
        "[RelativePopulationSizeMovers]") {

    SECTION("Testing 3 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> alphas = {5.0, 10.0, 15.0};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size:\n";
        os << "            value: 0.005\n";
        os << "            estimate: false\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size_multipliers:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                dirichlet_distribution:\n";
        os << "                    alpha: [" << alphas.at(0);
        for (unsigned int i = 1; i < alphas.size(); ++i) {
            os << ", " << alphas.at(i);
        }
        os << "]\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        std::shared_ptr<OperatorInterface> op1 = std::make_shared<RootRelativePopulationSizeMover>(0, 1.0, 0.1);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<LeafRelativePopulationSizeMover>(0, 1.0, 0.1);
        std::shared_ptr<OperatorInterface> op3 = std::make_shared<RootRelativePopulationSizeMover>(2, 1.0, 0.1);
        std::shared_ptr<OperatorInterface> op4 = std::make_shared<LeafRelativePopulationSizeMover>(2, 1.0, 0.1);
        op_schedule.add_operator(op1);
        op_schedule.add_operator(op2);
        op_schedule.add_operator(op3);
        op_schedule.add_operator(op4);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        REQUIRE(comparisons.get_number_of_events() == ntrees);

        std::vector< SampleSummarizer<double> > root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > leaf0_summaries(ntrees);
        std::vector< SampleSummarizer<double> > leaf1_summaries(ntrees);

        DirichletDistribution dir_prior = DirichletDistribution(alphas);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 6;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    std::vector<double> sizes = tree->get_population_sizes_as_proportions();
                    root_summaries.at(tree_idx).add_sample(sizes.at(sizes.size() - 1));
                    leaf0_summaries.at(tree_idx).add_sample(sizes.at(0));
                    leaf1_summaries.at(tree_idx).add_sample(sizes.at(1));
                }
            }
        }
        std::cout << op1->header_string();
        std::cout << op1->to_string(op_schedule);
        std::cout << op2->to_string(op_schedule);
        std::cout << op3->to_string(op_schedule);
        std::cout << op4->to_string(op_schedule);
        
        unsigned int tree_idx = 0;
        REQUIRE(root_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(root_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(root_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(leaf0_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf0_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(leaf0_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        REQUIRE(leaf1_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf1_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(leaf1_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));

        tree_idx = 1;
        REQUIRE(root_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(root_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(leaf0_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf0_summaries.at(tree_idx).variance() == Approx(0.0));

        REQUIRE(leaf1_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf1_summaries.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        REQUIRE(root_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(root_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(2)).epsilon(0.005));
        REQUIRE(root_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(2)).epsilon(0.005));

        REQUIRE(leaf0_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf0_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(0)).epsilon(0.005));
        REQUIRE(leaf0_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(0)).epsilon(0.005));

        REQUIRE(leaf1_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf1_summaries.at(tree_idx).mean() == Approx(dir_prior.get_mean(1)).epsilon(0.005));
        REQUIRE(leaf1_summaries.at(tree_idx).variance() == Approx(dir_prior.get_variance(1)).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific PopulationSizeScalers with 3 pairs",
        "[PopulationSizeScalers]") {

    SECTION("Testing 3 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> size_shapes {10.0, 5.0, 8.0};
        std::vector<double> size_scales {0.1, 0.1, 0.2};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    equal_population_sizes: false\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(0) << "\n";
        os << "                    scale: " << size_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(1) << "\n";
        os << "                    scale: " << size_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << size_shapes.at(2) << "\n";
        os << "                    scale: " << size_scales.at(2) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        CollectionSettings settings = CollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(111);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        std::shared_ptr<OperatorInterface> op1 = std::make_shared<RootPopulationSizeScaler>(0, 1.0, 0.5);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<LeafPopulationSizeScaler>(0, 1.0, 0.5);
        std::shared_ptr<OperatorInterface> op3 = std::make_shared<RootPopulationSizeScaler>(2, 1.0, 0.5);
        std::shared_ptr<OperatorInterface> op4 = std::make_shared<LeafPopulationSizeScaler>(2, 1.0, 0.5);
        op_schedule.add_operator(op1);
        op_schedule.add_operator(op2);
        op_schedule.add_operator(op3);
        op_schedule.add_operator(op4);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        REQUIRE(comparisons.get_number_of_events() == ntrees);

        std::vector< SampleSummarizer<double> > root_summaries(ntrees);
        std::vector< SampleSummarizer<double> > leaf0_summaries(ntrees);
        std::vector< SampleSummarizer<double> > leaf1_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 6;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    root_summaries.at(tree_idx).add_sample(tree->get_root_population_size());
                    leaf0_summaries.at(tree_idx).add_sample(tree->get_child_population_size(0));
                    leaf1_summaries.at(tree_idx).add_sample(tree->get_child_population_size(1));
                }
            }
        }
        std::cout << op1->header_string();
        std::cout << op1->to_string(op_schedule);
        std::cout << op2->to_string(op_schedule);
        std::cout << op3->to_string(op_schedule);
        std::cout << op4->to_string(op_schedule);
        
        unsigned int tree_idx = 0;
        double sh = size_shapes.at(tree_idx);
        double sc = size_scales.at(tree_idx);

        REQUIRE(root_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(root_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(root_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));

        REQUIRE(leaf0_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf0_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(leaf0_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));

        REQUIRE(leaf1_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf1_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(leaf1_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));

        tree_idx = 1;
        sh = size_shapes.at(tree_idx);
        sc = size_scales.at(tree_idx);

        REQUIRE(root_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(root_summaries.at(tree_idx).variance() == Approx(0.0));
        REQUIRE(leaf0_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf0_summaries.at(tree_idx).variance() == Approx(0.0));
        REQUIRE(leaf1_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf1_summaries.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        sh = size_shapes.at(tree_idx);
        sc = size_scales.at(tree_idx);

        REQUIRE(root_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(root_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(root_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));

        REQUIRE(leaf0_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf0_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(leaf0_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));

        REQUIRE(leaf1_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(leaf1_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(leaf1_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));
    }
}

TEST_CASE("Testing tree-specific MutationRateScaler with 3 pairs",
        "[MutationRateScaler]") {

    SECTION("Testing 3 pairs with optimizing") {
        double height_shape = 5.0;
        double height_scale = 0.1;
        std::vector<double> rate_shapes {10.0, 5.0, 5.0};
        std::vector<double> rate_scales {0.1, 0.1, 0.5};
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-test1-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-test1-" + tag + "-state-run-1.log";
        std::ofstream os;
        os.open(test_path);
        os << "event_time_prior:\n";
        os << "    gamma_distribution:\n";
        os << "        shape: " << height_shape << "\n";
        os << "        scale: " << height_scale << "\n";
        os << "global_comparison_settings:\n";
        os << "    genotypes_are_diploid: true\n";
        os << "    markers_are_dominant: false\n";
        os << "    population_name_delimiter: \" \"\n";
        os << "    population_name_is_prefix: true\n";
        os << "    constant_sites_removed: true\n";
        os << "    parameters:\n";
        os << "        population_size:\n";
        os << "            value: 1.0\n";
        os << "            estimate: false\n";
        os << "        population_size_multipliers:\n";
        os << "            value: [1.0, 1.0, 1.0]\n";
        os << "            estimate: false\n";
        os << "        freq_1:\n";
        os << "            value: 0.5\n";
        os << "            estimate: false\n";
        os << "comparisons:\n";
        os << "- comparison:\n";
        os << "    path: hemi129.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << rate_shapes.at(0) << "\n";
        os << "                    scale: " << rate_scales.at(0) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname1.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << rate_shapes.at(1) << "\n";
        os << "                    scale: " << rate_scales.at(1) << "\n";
        os << "- comparison:\n";
        os << "    path: hemi129-altname2.nex\n";
        os << "    parameters:\n";
        os << "        mutation_rate:\n";
        os << "            estimate: true\n";
        os << "            prior:\n";
        os << "                gamma_distribution:\n";
        os << "                    shape: " << rate_shapes.at(2) << "\n";
        os << "                    scale: " << rate_scales.at(2) << "\n";
        os.close();
        REQUIRE(path::exists(test_path));

        DirichletCollectionSettings settings = DirichletCollectionSettings(test_path);

        RandomNumberGenerator rng = RandomNumberGenerator(123456);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        std::shared_ptr<OperatorInterface> op1 = std::make_shared<MutationRateScaler>(0, 1.0, 0.5);
        std::shared_ptr<OperatorInterface> op2 = std::make_shared<MutationRateScaler>(2, 1.0, 0.5);
        op_schedule.add_operator(op1);
        op_schedule.add_operator(op2);

        ComparisonDirichletPopulationTreeCollection comparisons = ComparisonDirichletPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        unsigned int ntrees = comparisons.get_number_of_trees();
        REQUIRE(ntrees == 3);
        REQUIRE(comparisons.get_number_of_events() == ntrees);

        std::vector< SampleSummarizer<double> > rate_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 400000;
        unsigned int sample_freq = 4;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    rate_summaries.at(tree_idx).add_sample(tree->get_mutation_rate());
                }
            }
        }
        std::cout << op1->header_string();
        std::cout << op1->to_string(op_schedule);
        std::cout << op2->to_string(op_schedule);
        
        unsigned int tree_idx = 0;
        double sh = rate_shapes.at(tree_idx);
        double sc = rate_scales.at(tree_idx);

        REQUIRE(rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(rate_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(rate_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));

        tree_idx = 1;
        sh = rate_shapes.at(tree_idx);
        sc = rate_scales.at(tree_idx);

        REQUIRE(rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(rate_summaries.at(tree_idx).variance() == Approx(0.0));

        tree_idx = 2;
        sh = rate_shapes.at(tree_idx);
        sc = rate_scales.at(tree_idx);

        REQUIRE(rate_summaries.at(tree_idx).sample_size() == nsamples);
        REQUIRE(rate_summaries.at(tree_idx).mean() == Approx(sh * sc).epsilon(0.005));
        REQUIRE(rate_summaries.at(tree_idx).variance() == Approx(sh * sc * sc).epsilon(0.005));
    }
}

TEST_CASE("Testing derived operator interface metadata",
        "[OperatorInterfaceMetadata]") {

    SECTION("FreqMover") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<FreqMover>(0, 1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::tree_operator);
        REQUIRE(op->get_name() == "FreqMover0");
    }
    SECTION("MutationRateScaler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<MutationRateScaler>(0, 1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::tree_operator);
        REQUIRE(op->get_name() == "MutationRateScaler0");
    }
    SECTION("RootPopulationSizeScaler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<RootPopulationSizeScaler>(0, 1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::tree_operator);
        REQUIRE(op->get_name() == "RootPopulationSizeScaler0");
    }
    SECTION("LeafPopulationSizeScaler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<LeafPopulationSizeScaler>(0, 1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::tree_operator);
        REQUIRE(op->get_name() == "LeafPopulationSizeScaler0");
    }
    SECTION("RootRelativePopulationSizeMover") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<RootRelativePopulationSizeMover>(0, 1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::tree_operator);
        REQUIRE(op->get_name() == "RootRelativePopulationSizeMover0");
    }
    SECTION("LeafRelativePopulationSizeMover") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<LeafRelativePopulationSizeMover>(0, 1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::tree_operator);
        REQUIRE(op->get_name() == "LeafRelativePopulationSizeMover0");
    }
    SECTION("MeanPopulationSizeScaler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<MeanPopulationSizeScaler>(0, 1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::tree_operator);
        REQUIRE(op->get_name() == "MeanPopulationSizeScaler0");
    }
    SECTION("RelativePopulationSizeMixer") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<RelativePopulationSizeMixer>(0, 1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::tree_operator);
        REQUIRE(op->get_name() == "RelativePopulationSizeMixer0");
    }
    SECTION("EventTimeScaler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<EventTimeScaler>(1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::time_operator);
        REQUIRE(op->get_name() == "EventTimeScaler");
    }
    SECTION("EventTimeMover") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<EventTimeMover>(1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::time_operator);
        REQUIRE(op->get_name() == "EventTimeMover");
    }
    SECTION("DirichletProcessGibbsSampler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<DirichletProcessGibbsSampler>(1.0);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::collection_operator);
        REQUIRE(op->get_name() == "DirichletProcessGibbsSampler");
    }
    SECTION("ReversibleJumpSampler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<ReversibleJumpSampler>(1.0);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::rj_operator);
        REQUIRE(op->get_name() == "ReversibleJumpSampler");
    }
    SECTION("TimeSizeMixer") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeMixer>(1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::multivariate_time_operator);
        REQUIRE(op->get_name() == "TimeSizeMixer");
    }
    SECTION("TimeSizeScaler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeScaler>(1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::multivariate_time_operator);
        REQUIRE(op->get_name() == "TimeSizeScaler");
    }
    SECTION("TimeSizeRateMixer") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateMixer>(1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::multivariate_time_operator);
        REQUIRE(op->get_name() == "TimeSizeRateMixer");
    }
    SECTION("TimeSizeRateScaler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeSizeRateScaler>(1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::multivariate_time_operator);
        REQUIRE(op->get_name() == "TimeSizeRateScaler");
    }
    SECTION("TimeMeanSizeRateScaler") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateScaler>(1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::multivariate_time_operator);
        REQUIRE(op->get_name() == "TimeMeanSizeRateScaler");
    }
    SECTION("TimeMeanSizeRateMixer") {
        std::shared_ptr<OperatorInterface> op = std::make_shared<TimeMeanSizeRateMixer>(1.0, 0.1);
        REQUIRE(op->get_type() == OperatorInterface::OperatorTypeEnum::multivariate_time_operator);
        REQUIRE(op->get_name() == "TimeMeanSizeRateMixer");
    }
}


TEST_CASE("Testing tree-specific EventTimeScaler", "[EventTimeScaler]") {

    SECTION("Testing tree-specific moves with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_model_prior:\n";
        out << "    fixed: [0, 1, 2]\n";
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << shape << "\n";
        out << "        scale: " << scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out << "- comparison:\n";
        out << "    path: hemi129-altname1.nex\n";
        out << "- comparison:\n";
        out << "    path: hemi129-altname2.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        RandomNumberGenerator rng = RandomNumberGenerator(12345);

        CollectionSettings settings = CollectionSettings(test_path);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        unsigned int ntrees = comparisons.get_number_of_trees();
        for (unsigned int i = 0; i < ntrees; ++i) {
            op_schedule.add_operator(std::make_shared<EventTimeScaler>(i, 1.0, 0.5));
        }

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::vector< SampleSummarizer<double> > time_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 6;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(ntrees == comparisons.get_number_of_events());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    time_summaries.at(tree_idx).add_sample(tree->get_root_height());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(time_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(time_summaries.at(tree_idx).mean() == Approx(shape * scale).epsilon(0.001));
            REQUIRE(time_summaries.at(tree_idx).variance() == Approx(shape * scale * scale).epsilon(0.002));
        }
    }
}

TEST_CASE("Testing tree-specific EventTimeMover", "[EventTimeMover]") {

    SECTION("Testing tree-specific moves with optimizing") {
        double shape = 10.0;
        double scale = 0.1;
        std::string tag = _TEST_OPERATOR_RNG.random_string(10);
        std::string test_path = "data/tmp-config-" + tag + ".cfg";
        std::string log_path = "data/tmp-config-" + tag + "-state-run-1.log";
        std::ofstream out;
        out.open(test_path);
        out << "event_model_prior:\n";
        out << "    fixed: [0, 1, 2]\n";
        out << "event_time_prior:\n";
        out << "    gamma_distribution:\n";
        out << "        shape: " << shape << "\n";
        out << "        scale: " << scale << "\n";
        out << "global_comparison_settings:\n";
        out << "    genotypes_are_diploid: true\n";
        out << "    markers_are_dominant: false\n";
        out << "    population_name_delimiter: \" \"\n";
        out << "    population_name_is_prefix: true\n";
        out << "    constant_sites_removed: true\n";
        out << "    equal_population_sizes: true\n";
        out << "    parameters:\n";
        out << "        population_size:\n";
        out << "            value: 0.005\n";
        out << "            estimate: false\n";
        out << "        freq_1:\n";
        out << "            value: 0.5\n";
        out << "            estimate: false\n";
        out << "        mutation_rate:\n";
        out << "            value: 1.0\n";
        out << "            estimate: false\n";
        out << "comparisons:\n";
        out << "- comparison:\n";
        out << "    path: hemi129.nex\n";
        out << "- comparison:\n";
        out << "    path: hemi129-altname1.nex\n";
        out << "- comparison:\n";
        out << "    path: hemi129-altname2.nex\n";
        out.close();
        REQUIRE(path::exists(test_path));

        RandomNumberGenerator rng = RandomNumberGenerator(12345);

        CollectionSettings settings = CollectionSettings(test_path);
        OperatorSchedule op_schedule = OperatorSchedule();
        op_schedule.turn_on_auto_optimize();
        op_schedule.set_auto_optimize_delay(100);

        ComparisonPopulationTreeCollection comparisons = ComparisonPopulationTreeCollection(settings, rng);
        comparisons.ignore_data();

        unsigned int ntrees = comparisons.get_number_of_trees();
        for (unsigned int i = 0; i < ntrees; ++i) {
            op_schedule.add_operator(std::make_shared<EventTimeMover>(i, 1.0, 0.5));
        }

        // Initialize prior probs
        comparisons.compute_log_likelihood_and_prior(true);

        std::vector< SampleSummarizer<double> > time_summaries(ntrees);

        comparisons.set_operator_schedule(op_schedule);
        unsigned int niterations = 600000;
        unsigned int sample_freq = 6;
        unsigned int nsamples = niterations / sample_freq;
        for (unsigned int i = 0; i < niterations; ++i) {
            OperatorInterface& o = op_schedule.draw_operator(rng);
            o.operate(rng, &comparisons, 1);
            if ((i + 1) % sample_freq == 0) {
                REQUIRE(ntrees == comparisons.get_number_of_events());
                for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
                    std::shared_ptr<PopulationTree> tree = comparisons.get_tree(tree_idx);
                    time_summaries.at(tree_idx).add_sample(tree->get_root_height());
                }
            }
        }
        op_schedule.write_operator_rates(std::cout);

        for (unsigned int tree_idx = 0; tree_idx < ntrees; ++tree_idx) {
            REQUIRE(time_summaries.at(tree_idx).sample_size() == nsamples);
            REQUIRE(time_summaries.at(tree_idx).mean() == Approx(shape * scale).epsilon(0.001));
            REQUIRE(time_summaries.at(tree_idx).variance() == Approx(shape * scale * scale).epsilon(0.002));
        }
    }
}
